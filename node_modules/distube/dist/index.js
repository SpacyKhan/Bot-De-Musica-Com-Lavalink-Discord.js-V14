"use strict";
var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __name = (target, value) => __defProp(target, "name", { value, configurable: true });
var __commonJS = (cb, mod) => function __require() {
  return mod || (0, cb[__getOwnPropNames(cb)[0]])((mod = { exports: {} }).exports, mod), mod.exports;
};
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toESM = (mod, isNodeMode, target) => (target = mod != null ? __create(__getProtoOf(mod)) : {}, __copyProps(
  // If the importer is in node compatibility mode or this is not an ESM
  // file that has been converted to a CommonJS file using a Babel-
  // compatible transform (i.e. "__esModule" has not been set), then set
  // "default" to the CommonJS "module.exports" for node compatibility.
  isNodeMode || !mod || !mod.__esModule ? __defProp(target, "default", { value: mod, enumerable: true }) : target,
  mod
));
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};
var __accessCheck = (obj, member, msg) => {
  if (!member.has(obj))
    throw TypeError("Cannot " + msg);
};
var __privateGet = (obj, member, getter) => {
  __accessCheck(obj, member, "read from private field");
  return getter ? getter.call(obj) : member.get(obj);
};
var __privateAdd = (obj, member, value) => {
  if (member.has(obj))
    throw TypeError("Cannot add the same private member more than once");
  member instanceof WeakSet ? member.add(obj) : member.set(obj, value);
};
var __privateSet = (obj, member, value, setter) => {
  __accessCheck(obj, member, "write to private field");
  setter ? setter.call(obj, value) : member.set(obj, value);
  return value;
};
var __privateMethod = (obj, member, method) => {
  __accessCheck(obj, member, "access private method");
  return method;
};

// package.json
var require_package = __commonJS({
  "package.json"(exports2, module2) {
    module2.exports = {
      name: "distube",
      version: "4.2.2",
      description: "A Discord.js module to simplify your music commands and play songs with audio filters on Discord without any API key.",
      main: "./dist/index.js",
      types: "./dist/index.d.ts",
      exports: "./dist/index.js",
      directories: {
        lib: "src",
        test: "tests"
      },
      files: [
        "dist"
      ],
      scripts: {
        test: "jest",
        docs: "typedoc",
        lint: "prettier --check . && eslint .",
        "lint:fix": "eslint . --fix",
        prettier: 'prettier --write "**/*.{ts,json,yml,yaml,md}"',
        build: "tsup",
        "build:check": "tsc --noEmit",
        update: "pnpm up -L",
        postinstall: "husky",
        prepublishOnly: "pnpm run lint && pnpm run test",
        prepack: "pnpm run build && pinst --disable",
        postpack: "pinst --enable",
        "dev:add-docs-to-worktree": "git worktree add --track -b docs docs origin/docs"
      },
      repository: {
        type: "git",
        url: "git+https://github.com/skick1234/DisTube.git"
      },
      keywords: [
        "youtube",
        "music",
        "discord",
        "discordjs",
        "bot",
        "distube",
        "queue",
        "musicbot",
        "discord-music-bot",
        "music-bot",
        "discord-js"
      ],
      author: "Skick (https://github.com/skick1234)",
      license: "MIT",
      bugs: {
        url: "https://github.com/skick1234/DisTube/issues"
      },
      funding: "https://github.com/skick1234/DisTube?sponsor=1",
      homepage: "https://distube.js.org/",
      dependencies: {
        "@distube/ytdl-core": "^4.13.3",
        "@distube/ytpl": "^1.2.1",
        "@distube/ytsr": "^2.0.0",
        "tiny-typed-emitter": "^2.1.0",
        "tough-cookie": "^4.1.3",
        tslib: "^2.6.2",
        undici: "^6.13.0"
      },
      devDependencies: {
        "@babel/core": "^7.24.4",
        "@babel/plugin-transform-class-properties": "^7.24.1",
        "@babel/plugin-transform-object-rest-spread": "^7.24.1",
        "@babel/plugin-transform-private-methods": "^7.24.1",
        "@babel/preset-env": "^7.24.4",
        "@babel/preset-typescript": "^7.24.1",
        "@commitlint/cli": "^19.2.2",
        "@commitlint/config-conventional": "^19.2.2",
        "@discordjs/voice": "^0.16.1",
        "@types/jest": "^29.5.12",
        "@types/node": "^20.12.7",
        "@types/tough-cookie": "^4.0.5",
        "@typescript-eslint/eslint-plugin": "^7.7.0",
        "@typescript-eslint/parser": "^7.7.0",
        "babel-jest": "^29.7.0",
        "discord.js": "^14.14.1",
        eslint: "^8.57.0",
        "eslint-config-distube": "^1.7.0",
        husky: "^9.0.11",
        jest: "^29.7.0",
        "nano-staged": "^0.8.0",
        pinst: "^3.0.0",
        prettier: "^3.2.5",
        tsup: "^8.0.2",
        typedoc: "^0.25.13",
        "typedoc-material-theme": "^1.0.2",
        typescript: "^5.4.5"
      },
      peerDependencies: {
        "@discordjs/voice": "*",
        "discord.js": "14"
      },
      "nano-staged": {
        "*.ts": [
          "prettier --write",
          "eslint"
        ],
        "*.{json,yml,yaml,md}": [
          "prettier --write"
        ]
      },
      engines: {
        node: ">=18.17"
      }
    };
  }
});

// src/index.ts
var src_exports = {};
__export(src_exports, {
  BaseManager: () => BaseManager,
  CustomPlugin: () => CustomPlugin,
  DirectLinkPlugin: () => DirectLinkPlugin,
  DisTube: () => DisTube,
  DisTubeBase: () => DisTubeBase,
  DisTubeError: () => DisTubeError,
  DisTubeHandler: () => DisTubeHandler,
  DisTubeStream: () => DisTubeStream,
  DisTubeVoice: () => DisTubeVoice,
  DisTubeVoiceManager: () => DisTubeVoiceManager,
  Events: () => Events,
  ExtractorPlugin: () => ExtractorPlugin,
  FilterManager: () => FilterManager,
  GuildIdManager: () => GuildIdManager,
  Options: () => Options,
  Playlist: () => Playlist,
  Plugin: () => Plugin,
  PluginType: () => PluginType,
  Queue: () => Queue,
  QueueManager: () => QueueManager,
  RepeatMode: () => RepeatMode,
  SearchResultPlaylist: () => SearchResultPlaylist,
  SearchResultType: () => SearchResultType,
  SearchResultVideo: () => SearchResultVideo,
  Song: () => Song,
  StreamType: () => StreamType,
  TaskQueue: () => TaskQueue,
  checkFFmpeg: () => checkFFmpeg,
  checkIntents: () => checkIntents,
  checkInvalidKey: () => checkInvalidKey,
  chooseBestVideoFormat: () => chooseBestVideoFormat,
  default: () => DisTube,
  defaultFilters: () => defaultFilters,
  defaultOptions: () => defaultOptions,
  formatDuration: () => formatDuration,
  isClientInstance: () => isClientInstance,
  isGuildInstance: () => isGuildInstance,
  isMemberInstance: () => isMemberInstance,
  isMessageInstance: () => isMessageInstance,
  isNsfwChannel: () => isNsfwChannel,
  isObject: () => isObject,
  isRecord: () => isRecord,
  isSnowflake: () => isSnowflake,
  isSupportedVoiceChannel: () => isSupportedVoiceChannel,
  isTextChannelInstance: () => isTextChannelInstance,
  isTruthy: () => isTruthy,
  isURL: () => isURL,
  isVoiceChannelEmpty: () => isVoiceChannelEmpty,
  objectKeys: () => objectKeys,
  parseNumber: () => parseNumber,
  resolveGuildId: () => resolveGuildId,
  toSecond: () => toSecond,
  version: () => version
});
module.exports = __toCommonJS(src_exports);

// src/type.ts
var RepeatMode = /* @__PURE__ */ ((RepeatMode2) => {
  RepeatMode2[RepeatMode2["DISABLED"] = 0] = "DISABLED";
  RepeatMode2[RepeatMode2["SONG"] = 1] = "SONG";
  RepeatMode2[RepeatMode2["QUEUE"] = 2] = "QUEUE";
  return RepeatMode2;
})(RepeatMode || {});
var PluginType = /* @__PURE__ */ ((PluginType2) => {
  PluginType2["CUSTOM"] = "custom";
  PluginType2["EXTRACTOR"] = "extractor";
  return PluginType2;
})(PluginType || {});
var SearchResultType = /* @__PURE__ */ ((SearchResultType2) => {
  SearchResultType2["VIDEO"] = "video";
  SearchResultType2["PLAYLIST"] = "playlist";
  return SearchResultType2;
})(SearchResultType || {});
var StreamType = /* @__PURE__ */ ((StreamType2) => {
  StreamType2[StreamType2["OPUS"] = 0] = "OPUS";
  StreamType2[StreamType2["RAW"] = 1] = "RAW";
  return StreamType2;
})(StreamType || {});
var Events = /* @__PURE__ */ ((Events2) => {
  Events2["ERROR"] = "error";
  Events2["ADD_LIST"] = "addList";
  Events2["ADD_SONG"] = "addSong";
  Events2["PLAY_SONG"] = "playSong";
  Events2["FINISH_SONG"] = "finishSong";
  Events2["EMPTY"] = "empty";
  Events2["FINISH"] = "finish";
  Events2["INIT_QUEUE"] = "initQueue";
  Events2["NO_RELATED"] = "noRelated";
  Events2["DISCONNECT"] = "disconnect";
  Events2["DELETE_QUEUE"] = "deleteQueue";
  Events2["SEARCH_CANCEL"] = "searchCancel";
  Events2["SEARCH_NO_RESULT"] = "searchNoResult";
  Events2["SEARCH_DONE"] = "searchDone";
  Events2["SEARCH_INVALID_ANSWER"] = "searchInvalidAnswer";
  Events2["SEARCH_RESULT"] = "searchResult";
  Events2["FFMPEG_DEBUG"] = "ffmpegDebug";
  return Events2;
})(Events || {});

// src/constant.ts
var defaultFilters = {
  "3d": "apulsator=hz=0.125",
  bassboost: "bass=g=10",
  echo: "aecho=0.8:0.9:1000:0.3",
  flanger: "flanger",
  gate: "agate",
  haas: "haas",
  karaoke: "stereotools=mlev=0.1",
  nightcore: "asetrate=48000*1.25,aresample=48000,bass=g=5",
  reverse: "areverse",
  vaporwave: "asetrate=48000*0.8,aresample=48000,atempo=1.1",
  mcompand: "mcompand",
  phaser: "aphaser",
  tremolo: "tremolo",
  surround: "surround",
  earwax: "earwax"
};
var defaultOptions = {
  plugins: [],
  emitNewSongOnly: false,
  leaveOnEmpty: true,
  leaveOnFinish: false,
  leaveOnStop: true,
  savePreviousSongs: true,
  searchSongs: 0,
  ytdlOptions: {},
  searchCooldown: 60,
  emptyCooldown: 60,
  nsfw: false,
  emitAddSongWhenCreatingQueue: true,
  emitAddListWhenCreatingQueue: true,
  joinNewVoiceChannel: true,
  streamType: 0 /* OPUS */,
  directLink: true
};

// src/struct/DisTubeError.ts
var import_node_util = require("util");
var ERROR_MESSAGES = {
  INVALID_TYPE: (expected, got, name) => `Expected ${Array.isArray(expected) ? expected.map((e) => typeof e === "number" ? e : `'${e}'`).join(" or ") : `'${expected}'`}${name ? ` for '${name}'` : ""}, but got ${(0, import_node_util.inspect)(got)} (${typeof got})`,
  NUMBER_COMPARE: (name, expected, value) => `'${name}' must be ${expected} ${value}`,
  EMPTY_ARRAY: (name) => `'${name}' is an empty array`,
  EMPTY_FILTERED_ARRAY: (name, type) => `There is no valid '${type}' in the '${name}' array`,
  EMPTY_STRING: (name) => `'${name}' string must not be empty`,
  INVALID_KEY: (obj, key) => `'${key}' does not need to be provided in ${obj}`,
  MISSING_KEY: (obj, key) => `'${key}' needs to be provided in ${obj}`,
  MISSING_KEYS: (obj, key, all) => `${key.map((k) => `'${k}'`).join(all ? " and " : " or ")} need to be provided in ${obj}`,
  MISSING_INTENTS: (i) => `${i} intent must be provided for the Client`,
  DISABLED_OPTION: (o) => `DisTubeOptions.${o} is disabled`,
  ENABLED_OPTION: (o) => `DisTubeOptions.${o} is enabled`,
  NOT_IN_VOICE: "User is not in any voice channel",
  VOICE_FULL: "The voice channel is full",
  VOICE_CONNECT_FAILED: (s) => `Cannot connect to the voice channel after ${s} seconds`,
  VOICE_MISSING_PERMS: "I do not have permission to join this voice channel",
  VOICE_RECONNECT_FAILED: "Cannot reconnect to the voice channel",
  VOICE_DIFFERENT_GUILD: "Cannot join a voice channel in a different guild",
  VOICE_DIFFERENT_CLIENT: "Cannot join a voice channel created by a different client",
  FFMPEG_EXITED: (code) => `ffmpeg exited with code ${code}`,
  FFMPEG_NOT_INSTALLED: (path) => `ffmpeg is not installed at '${path}' path`,
  NO_QUEUE: "There is no playing queue in this guild",
  QUEUE_EXIST: "This guild has a Queue already",
  PAUSED: "The queue has been paused already",
  RESUMED: "The queue has been playing already",
  NO_PREVIOUS: "There is no previous song in this queue",
  NO_UP_NEXT: "There is no up next song",
  NO_SONG_POSITION: "Does not have any song at this position",
  NO_PLAYING: "There is no playing song in the queue",
  NO_RESULT: "No result found",
  NO_RELATED: "Cannot find any related songs",
  CANNOT_PLAY_RELATED: "Cannot play the related song",
  UNAVAILABLE_VIDEO: "This video is unavailable",
  UNPLAYABLE_FORMATS: "No playable format found",
  NON_NSFW: "Cannot play age-restricted content in non-NSFW channel",
  NOT_SUPPORTED_URL: "This url is not supported",
  CANNOT_RESOLVE_SONG: (t) => `Cannot resolve ${(0, import_node_util.inspect)(t)} to a Song`,
  NO_VALID_SONG: "'songs' array does not have any valid Song, SearchResult or url",
  EMPTY_FILTERED_PLAYLIST: "There is no valid video in the playlist\nMaybe age-restricted contents is filtered because you are in non-NSFW channel",
  EMPTY_PLAYLIST: "There is no valid video in the playlist"
};
var haveCode = /* @__PURE__ */ __name((code) => Object.keys(ERROR_MESSAGES).includes(code), "haveCode");
var parseMessage = /* @__PURE__ */ __name((m, ...args) => typeof m === "string" ? m : m(...args), "parseMessage");
var getErrorMessage = /* @__PURE__ */ __name((code, ...args) => haveCode(code) ? parseMessage(ERROR_MESSAGES[code], ...args) : args[0], "getErrorMessage");
var _DisTubeError = class _DisTubeError extends Error {
  constructor(code, ...args) {
    super(getErrorMessage(code, ...args));
    __publicField(this, "errorCode");
    this.errorCode = code;
    if (Error.captureStackTrace)
      Error.captureStackTrace(this, _DisTubeError);
  }
  get name() {
    return `DisTubeError [${this.errorCode}]`;
  }
  get code() {
    return this.errorCode;
  }
};
__name(_DisTubeError, "DisTubeError");
var DisTubeError = _DisTubeError;

// src/struct/TaskQueue.ts
var _Task = class _Task {
  constructor(resolveInfo) {
    __publicField(this, "resolve");
    __publicField(this, "promise");
    __publicField(this, "resolveInfo");
    this.resolveInfo = resolveInfo;
    this.promise = new Promise((res) => {
      this.resolve = res;
    });
  }
};
__name(_Task, "Task");
var Task = _Task;
var _tasks;
var _TaskQueue = class _TaskQueue {
  constructor() {
    /**
     * The task array
     */
    __privateAdd(this, _tasks, []);
  }
  /**
   * Waits for last task finished and queues a new task
   *
   * @param resolveInfo - Whether the task is a resolving info task
   */
  queuing(resolveInfo = false) {
    const next = this.remaining ? __privateGet(this, _tasks)[__privateGet(this, _tasks).length - 1].promise : Promise.resolve();
    __privateGet(this, _tasks).push(new Task(resolveInfo));
    return next;
  }
  /**
   * Removes the finished task and processes the next task
   */
  resolve() {
    __privateGet(this, _tasks).shift()?.resolve();
  }
  /**
   * The remaining number of tasks
   */
  get remaining() {
    return __privateGet(this, _tasks).length;
  }
  /**
   * Whether or not having a resolving info task
   */
  get hasResolveTask() {
    return __privateGet(this, _tasks).some((t) => t.resolveInfo);
  }
};
_tasks = new WeakMap();
__name(_TaskQueue, "TaskQueue");
var TaskQueue = _TaskQueue;

// src/struct/Playlist.ts
var _metadata, _member;
var _Playlist = class _Playlist {
  /**
   * Create a playlist
   *
   * @param playlist           - Playlist
   * @param options            - Optional options
   */
  constructor(playlist, options = {}) {
    __publicField(this, "source");
    __publicField(this, "songs");
    __publicField(this, "name");
    __privateAdd(this, _metadata, void 0);
    __privateAdd(this, _member, void 0);
    __publicField(this, "url");
    __publicField(this, "thumbnail");
    const { member, properties, metadata } = options;
    if (typeof playlist !== "object" || !Array.isArray(playlist) && ["source", "songs"].some((key) => !(key in playlist))) {
      throw new DisTubeError("INVALID_TYPE", ["Array<Song>", "PlaylistInfo"], playlist, "playlist");
    }
    if (typeof properties !== "undefined" && !isRecord(properties)) {
      throw new DisTubeError("INVALID_TYPE", "object", properties, "properties");
    }
    if (Array.isArray(playlist)) {
      this.source = "youtube";
      if (!playlist.length)
        throw new DisTubeError("EMPTY_PLAYLIST");
      this.songs = playlist;
      this.name = this.songs[0].name ? `${this.songs[0].name} and ${this.songs.length - 1} more songs.` : `${this.songs.length} songs playlist`;
      this.thumbnail = this.songs[0].thumbnail;
      this.member = member;
    } else {
      this.source = playlist.source.toLowerCase();
      if (!Array.isArray(playlist.songs) || !playlist.songs.length)
        throw new DisTubeError("EMPTY_PLAYLIST");
      this.songs = playlist.songs;
      this.name = playlist.name || // eslint-disable-next-line deprecation/deprecation
      playlist.title || (this.songs[0].name ? `${this.songs[0].name} and ${this.songs.length - 1} more songs.` : `${this.songs.length} songs playlist`);
      this.url = playlist.url || playlist.webpage_url;
      this.thumbnail = playlist.thumbnail || this.songs[0].thumbnail;
      this.member = member || playlist.member;
    }
    this.songs.forEach((s) => s.constructor.name === "Song" && (s.playlist = this));
    if (properties)
      for (const [key, value] of Object.entries(properties))
        this[key] = value;
    this.metadata = metadata;
  }
  /**
   * Playlist duration in second.
   */
  get duration() {
    return this.songs.reduce((prev, next) => prev + next.duration, 0);
  }
  /**
   * Formatted duration string `hh:mm:ss`.
   */
  get formattedDuration() {
    return formatDuration(this.duration);
  }
  /**
   * User requested.
   */
  get member() {
    return __privateGet(this, _member);
  }
  set member(member) {
    if (!isMemberInstance(member))
      return;
    __privateSet(this, _member, member);
    this.songs.forEach((s) => s.constructor.name === "Song" && (s.member = this.member));
  }
  /**
   * User requested.
   */
  get user() {
    return this.member?.user;
  }
  get metadata() {
    return __privateGet(this, _metadata);
  }
  set metadata(metadata) {
    __privateSet(this, _metadata, metadata);
    this.songs.forEach((s) => s.constructor.name === "Song" && (s.metadata = metadata));
  }
};
_metadata = new WeakMap();
_member = new WeakMap();
__name(_Playlist, "Playlist");
var Playlist = _Playlist;

// src/struct/SearchResult.ts
var _ISearchResult = class _ISearchResult {
  /**
   * Create a search result
   *
   * @param info - ytsr result
   */
  constructor(info) {
    __publicField(this, "source");
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "url");
    __publicField(this, "uploader");
    this.source = "youtube";
    this.id = info.id;
    this.name = info.name;
    this.url = info.url;
    this.uploader = {
      name: void 0,
      url: void 0
    };
  }
};
__name(_ISearchResult, "ISearchResult");
var ISearchResult = _ISearchResult;
var _SearchResultVideo = class _SearchResultVideo extends ISearchResult {
  constructor(info) {
    super(info);
    __publicField(this, "type");
    __publicField(this, "views");
    __publicField(this, "isLive");
    __publicField(this, "duration");
    __publicField(this, "formattedDuration");
    __publicField(this, "thumbnail");
    if (info.type !== "video")
      throw new DisTubeError("INVALID_TYPE", "video", info.type, "type");
    this.type = "video" /* VIDEO */;
    this.views = info.views;
    this.isLive = info.isLive;
    this.duration = this.isLive ? 0 : toSecond(info.duration);
    this.formattedDuration = this.isLive ? "Live" : formatDuration(this.duration);
    this.thumbnail = info.thumbnail;
    this.uploader = {
      name: info.author?.name,
      url: info.author?.url
    };
  }
};
__name(_SearchResultVideo, "SearchResultVideo");
var SearchResultVideo = _SearchResultVideo;
var _SearchResultPlaylist = class _SearchResultPlaylist extends ISearchResult {
  constructor(info) {
    super(info);
    __publicField(this, "type");
    __publicField(this, "length");
    if (info.type !== "playlist")
      throw new DisTubeError("INVALID_TYPE", "playlist", info.type, "type");
    this.type = "playlist" /* PLAYLIST */;
    this.length = info.length;
    this.uploader = {
      name: info.owner?.name,
      url: info.owner?.url
    };
  }
};
__name(_SearchResultPlaylist, "SearchResultPlaylist");
var SearchResultPlaylist = _SearchResultPlaylist;

// src/struct/Song.ts
var _metadata2, _member2, _playlist;
var _Song = class _Song {
  /**
   * Create a Song
   *
   * @param info             - Raw info
   * @param options          - Optional options
   */
  constructor(info, options = {}) {
    __publicField(this, "source");
    __privateAdd(this, _metadata2, void 0);
    __publicField(this, "formats");
    __privateAdd(this, _member2, void 0);
    __publicField(this, "id");
    __publicField(this, "name");
    __publicField(this, "isLive");
    __publicField(this, "duration");
    __publicField(this, "formattedDuration");
    __publicField(this, "url");
    __publicField(this, "streamURL");
    __publicField(this, "thumbnail");
    __publicField(this, "related");
    __publicField(this, "views");
    __publicField(this, "likes");
    __publicField(this, "dislikes");
    __publicField(this, "uploader");
    __publicField(this, "age_restricted");
    __publicField(this, "chapters");
    __publicField(this, "reposts");
    __privateAdd(this, _playlist, void 0);
    const { member, source, metadata } = { source: "youtube", ...options };
    if (typeof source !== "string" || info.src && typeof info.src !== "string") {
      throw new DisTubeError("INVALID_TYPE", "string", source, "source");
    }
    this.source = (info?.src || source).toLowerCase();
    this.metadata = metadata;
    this.member = member;
    if (this.source === "youtube") {
      this._patchYouTube(info);
    } else {
      this._patchOther(info);
    }
  }
  _patchYouTube(i) {
    const info = i;
    if (info.full === true) {
      this.formats = info.formats;
      const err = require("@distube/ytdl-core/lib/utils").playError(info.player_response, [
        "UNPLAYABLE",
        "LIVE_STREAM_OFFLINE",
        "LOGIN_REQUIRED"
      ]);
      if (err)
        throw err;
      if (!info.formats?.length)
        throw new DisTubeError("UNAVAILABLE_VIDEO");
    }
    const details = info.videoDetails || info;
    this.id = details.videoId || details.id;
    this.name = details.title || details.name;
    this.isLive = Boolean(details.isLive);
    this.duration = this.isLive ? 0 : toSecond(details.lengthSeconds || details.length_seconds || details.duration);
    this.formattedDuration = this.isLive ? "Live" : formatDuration(this.duration);
    this.url = `https://www.youtube.com/watch?v=${this.id}`;
    this.streamURL = void 0;
    this.thumbnail = details.thumbnails?.sort((a, b) => b.width - a.width)?.[0]?.url || details.thumbnail?.url || details.thumbnail;
    this.related = info?.related_videos || details.related || [];
    if (!Array.isArray(this.related))
      throw new DisTubeError("INVALID_TYPE", "Array", this.related, "Song#related");
    this.related = this.related.map((v) => new _Song(v, { source: this.source, metadata: this.metadata }));
    this.views = parseNumber(details.viewCount || details.view_count || details.views);
    this.likes = parseNumber(details.likes);
    this.dislikes = parseNumber(details.dislikes);
    this.uploader = {
      name: info.uploader?.name || details.author?.name,
      url: info.uploader?.url || details.author?.channel_url || details.author?.url
    };
    this.age_restricted = Boolean(details.age_restricted);
    this.chapters = details.chapters || [];
    this.reposts = 0;
  }
  /**
   * Patch data from other source
   *
   * @param info - Video info
   */
  _patchOther(info) {
    this.id = info.id;
    this.name = info.title || info.name;
    this.isLive = Boolean(info.is_live || info.isLive);
    this.duration = this.isLive ? 0 : toSecond(info._duration_raw || info.duration);
    this.formattedDuration = this.isLive ? "Live" : formatDuration(this.duration);
    this.url = info.webpage_url || info.url;
    this.thumbnail = info.thumbnail;
    this.related = info.related || [];
    if (!Array.isArray(this.related))
      throw new DisTubeError("INVALID_TYPE", "Array", this.related, "Song#related");
    this.related = this.related.map((i) => new _Song(i, { source: this.source, metadata: this.metadata }));
    this.views = parseNumber(info.view_count || info.views);
    this.likes = parseNumber(info.like_count || info.likes);
    this.dislikes = parseNumber(info.dislike_count || info.dislikes);
    this.reposts = parseNumber(info.repost_count || info.reposts);
    if (typeof info.uploader === "string") {
      this.uploader = {
        name: info.uploader,
        url: info.uploader_url
      };
    } else {
      this.uploader = {
        name: info.uploader?.name,
        url: info.uploader?.url
      };
    }
    this.age_restricted = info.age_restricted || Boolean(info.age_limit) && parseNumber(info.age_limit) >= 18;
    this.chapters = info.chapters || [];
  }
  /**
   * The playlist added this song
   */
  get playlist() {
    return __privateGet(this, _playlist);
  }
  set playlist(playlist) {
    if (!(playlist instanceof Playlist))
      throw new DisTubeError("INVALID_TYPE", "Playlist", playlist, "Song#playlist");
    __privateSet(this, _playlist, playlist);
    this.member = playlist.member;
  }
  /**
   * User requested.
   */
  get member() {
    return __privateGet(this, _member2);
  }
  set member(member) {
    if (isMemberInstance(member))
      __privateSet(this, _member2, member);
  }
  /**
   * User requested.
   */
  get user() {
    return this.member?.user;
  }
  get metadata() {
    return __privateGet(this, _metadata2);
  }
  set metadata(metadata) {
    __privateSet(this, _metadata2, metadata);
  }
};
_metadata2 = new WeakMap();
_member2 = new WeakMap();
_playlist = new WeakMap();
__name(_Song, "Song");
var Song = _Song;

// src/core/DisTubeBase.ts
var _DisTubeBase = class _DisTubeBase {
  constructor(distube) {
    __publicField(this, "distube");
    this.distube = distube;
  }
  /**
   * Emit the {@link DisTube} of this base
   *
   * @param eventName - Event name
   * @param args      - arguments
   */
  emit(eventName, ...args) {
    return this.distube.emit(eventName, ...args);
  }
  /**
   * Emit error event
   *
   * @param error   - error
   * @param channel - Text channel where the error is encountered.
   */
  emitError(error, channel) {
    this.distube.emitError(error, channel);
  }
  /**
   * The queue manager
   */
  get queues() {
    return this.distube.queues;
  }
  /**
   * The voice manager
   */
  get voices() {
    return this.distube.voices;
  }
  /**
   * Discord.js client
   */
  get client() {
    return this.distube.client;
  }
  /**
   * DisTube options
   */
  get options() {
    return this.distube.options;
  }
  /**
   * DisTube handler
   */
  get handler() {
    return this.distube.handler;
  }
};
__name(_DisTubeBase, "DisTubeBase");
var DisTubeBase = _DisTubeBase;

// src/core/DisTubeVoice.ts
var import_discord = require("discord.js");
var import_tiny_typed_emitter = require("tiny-typed-emitter");
var import_voice = require("@discordjs/voice");
var _channel, _volume, _br, br_fn, _join, join_fn;
var _DisTubeVoice = class _DisTubeVoice extends import_tiny_typed_emitter.TypedEmitter {
  constructor(voiceManager, channel) {
    super();
    __privateAdd(this, _br);
    __privateAdd(this, _join);
    __publicField(this, "id");
    __publicField(this, "voices");
    __publicField(this, "audioPlayer");
    __publicField(this, "connection");
    __publicField(this, "audioResource");
    __publicField(this, "emittedError");
    __publicField(this, "isDisconnected", false);
    __publicField(this, "stream");
    __privateAdd(this, _channel, void 0);
    __privateAdd(this, _volume, 100);
    this.voices = voiceManager;
    this.id = channel.guildId;
    this.channel = channel;
    this.voices.add(this.id, this);
    this.audioPlayer = (0, import_voice.createAudioPlayer)().on(import_voice.AudioPlayerStatus.Idle, (oldState) => {
      if (oldState.status !== import_voice.AudioPlayerStatus.Idle) {
        delete this.audioResource;
        this.emit("finish");
      }
    }).on(import_voice.AudioPlayerStatus.Playing, () => __privateMethod(this, _br, br_fn).call(this)).on("error", (error) => {
      if (this.emittedError)
        return;
      this.emittedError = true;
      this.emit("error", error);
    });
    this.connection.on(import_voice.VoiceConnectionStatus.Disconnected, (_, newState) => {
      if (newState.reason === import_voice.VoiceConnectionDisconnectReason.Manual) {
        this.leave();
      } else if (newState.reason === import_voice.VoiceConnectionDisconnectReason.WebSocketClose && newState.closeCode === 4014) {
        (0, import_voice.entersState)(this.connection, import_voice.VoiceConnectionStatus.Connecting, 5e3).catch(() => {
          if (![import_voice.VoiceConnectionStatus.Ready, import_voice.VoiceConnectionStatus.Connecting].includes(this.connection.state.status)) {
            this.leave();
          }
        });
      } else if (this.connection.rejoinAttempts < 5) {
        setTimeout(
          () => {
            this.connection.rejoin();
          },
          (this.connection.rejoinAttempts + 1) * 5e3
        ).unref();
      } else if (this.connection.state.status !== import_voice.VoiceConnectionStatus.Destroyed) {
        this.leave(new DisTubeError("VOICE_RECONNECT_FAILED"));
      }
    }).on(import_voice.VoiceConnectionStatus.Destroyed, () => {
      this.leave();
    }).on("error", () => void 0);
    this.connection.subscribe(this.audioPlayer);
  }
  /**
   * The voice channel id the bot is in
   */
  get channelId() {
    return this.connection?.joinConfig?.channelId ?? void 0;
  }
  get channel() {
    if (!this.channelId)
      return __privateGet(this, _channel);
    if (__privateGet(this, _channel)?.id === this.channelId)
      return __privateGet(this, _channel);
    const channel = this.voices.client.channels.cache.get(this.channelId);
    if (!channel)
      return __privateGet(this, _channel);
    for (const type of import_discord.Constants.VoiceBasedChannelTypes) {
      if (channel.type === type) {
        __privateSet(this, _channel, channel);
        return channel;
      }
    }
    return __privateGet(this, _channel);
  }
  set channel(channel) {
    if (!isSupportedVoiceChannel(channel)) {
      throw new DisTubeError("INVALID_TYPE", "BaseGuildVoiceChannel", channel, "DisTubeVoice#channel");
    }
    if (channel.guildId !== this.id)
      throw new DisTubeError("VOICE_DIFFERENT_GUILD");
    if (channel.client.user?.id !== this.voices.client.user?.id)
      throw new DisTubeError("VOICE_DIFFERENT_CLIENT");
    if (channel.id === this.channelId)
      return;
    if (!channel.joinable) {
      if (channel.full)
        throw new DisTubeError("VOICE_FULL");
      else
        throw new DisTubeError("VOICE_MISSING_PERMS");
    }
    this.connection = __privateMethod(this, _join, join_fn).call(this, channel);
    __privateSet(this, _channel, channel);
    __privateMethod(this, _br, br_fn).call(this);
  }
  /**
   * Join a voice channel with this connection
   *
   * @param channel - A voice channel
   */
  async join(channel) {
    const TIMEOUT = 3e4;
    if (channel)
      this.channel = channel;
    try {
      await (0, import_voice.entersState)(this.connection, import_voice.VoiceConnectionStatus.Ready, TIMEOUT);
    } catch {
      if (this.connection.state.status === import_voice.VoiceConnectionStatus.Ready)
        return this;
      if (this.connection.state.status !== import_voice.VoiceConnectionStatus.Destroyed)
        this.connection.destroy();
      this.voices.remove(this.id);
      throw new DisTubeError("VOICE_CONNECT_FAILED", TIMEOUT / 1e3);
    }
    return this;
  }
  /**
   * Leave the voice channel of this connection
   *
   * @param error - Optional, an error to emit with 'error' event.
   */
  leave(error) {
    this.stop(true);
    if (!this.isDisconnected) {
      this.emit("disconnect", error);
      this.isDisconnected = true;
    }
    if (this.connection.state.status !== import_voice.VoiceConnectionStatus.Destroyed)
      this.connection.destroy();
    this.voices.remove(this.id);
  }
  /**
   * Stop the playing stream
   *
   * @param force - If true, will force the {@link DisTubeVoice#audioPlayer} to enter the Idle state even
   *                if the {@link DisTubeVoice#audioResource} has silence padding frames.
   */
  stop(force = false) {
    this.audioPlayer.stop(force);
    this.stream?.kill?.();
  }
  /**
   * Play a {@link DisTubeStream}
   *
   * @param dtStream - DisTubeStream
   */
  play(dtStream) {
    this.emittedError = false;
    dtStream.on("error", (error) => {
      if (this.emittedError || error.code === "ERR_STREAM_PREMATURE_CLOSE")
        return;
      this.emittedError = true;
      this.emit("error", error);
    });
    this.audioResource = (0, import_voice.createAudioResource)(dtStream.stream, {
      inputType: dtStream.type,
      inlineVolume: true
    });
    this.volume = __privateGet(this, _volume);
    if (this.audioPlayer.state.status !== import_voice.AudioPlayerStatus.Paused)
      this.audioPlayer.play(this.audioResource);
    this.stream?.kill?.();
    this.stream = dtStream;
  }
  set volume(volume) {
    if (typeof volume !== "number" || isNaN(volume)) {
      throw new DisTubeError("INVALID_TYPE", "number", volume, "volume");
    }
    if (volume < 0) {
      throw new DisTubeError("NUMBER_COMPARE", "Volume", "bigger or equal to", 0);
    }
    __privateSet(this, _volume, volume);
    this.audioResource?.volume?.setVolume(Math.pow(__privateGet(this, _volume) / 100, 0.5 / Math.log10(2)));
  }
  get volume() {
    return __privateGet(this, _volume);
  }
  /**
   * Playback duration of the audio resource in seconds
   */
  get playbackDuration() {
    return (this.audioResource?.playbackDuration ?? 0) / 1e3;
  }
  pause() {
    this.audioPlayer.pause();
  }
  unpause() {
    const state = this.audioPlayer.state;
    if (state.status !== import_voice.AudioPlayerStatus.Paused)
      return;
    if (this.audioResource && state.resource !== this.audioResource)
      this.audioPlayer.play(this.audioResource);
    else
      this.audioPlayer.unpause();
  }
  /**
   * Whether the bot is self-deafened
   */
  get selfDeaf() {
    return this.connection.joinConfig.selfDeaf;
  }
  /**
   * Whether the bot is self-muted
   */
  get selfMute() {
    return this.connection.joinConfig.selfMute;
  }
  /**
   * Self-deafens/undeafens the bot.
   *
   * @param selfDeaf - Whether or not the bot should be self-deafened
   *
   * @returns true if the voice state was successfully updated, otherwise false
   */
  setSelfDeaf(selfDeaf) {
    if (typeof selfDeaf !== "boolean") {
      throw new DisTubeError("INVALID_TYPE", "boolean", selfDeaf, "selfDeaf");
    }
    return this.connection.rejoin({
      ...this.connection.joinConfig,
      selfDeaf
    });
  }
  /**
   * Self-mutes/unmutes the bot.
   *
   * @param selfMute - Whether or not the bot should be self-muted
   *
   * @returns true if the voice state was successfully updated, otherwise false
   */
  setSelfMute(selfMute) {
    if (typeof selfMute !== "boolean") {
      throw new DisTubeError("INVALID_TYPE", "boolean", selfMute, "selfMute");
    }
    return this.connection.rejoin({
      ...this.connection.joinConfig,
      selfMute
    });
  }
  /**
   * The voice state of this connection
   */
  get voiceState() {
    return this.channel?.guild?.members?.me?.voice;
  }
};
_channel = new WeakMap();
_volume = new WeakMap();
_br = new WeakSet();
br_fn = /* @__PURE__ */ __name(function() {
  if (this.audioResource?.encoder?.encoder)
    this.audioResource.encoder.setBitrate(this.channel.bitrate);
}, "#br");
_join = new WeakSet();
join_fn = /* @__PURE__ */ __name(function(channel) {
  return (0, import_voice.joinVoiceChannel)({
    channelId: channel.id,
    guildId: this.id,
    adapterCreator: channel.guild.voiceAdapterCreator,
    group: channel.client.user?.id
  });
}, "#join");
__name(_DisTubeVoice, "DisTubeVoice");
var DisTubeVoice = _DisTubeVoice;

// src/core/DisTubeStream.ts
var import_node_stream = require("stream");
var import_child_process = require("child_process");
var import_tiny_typed_emitter2 = require("tiny-typed-emitter");
var import_voice2 = require("@discordjs/voice");
var chooseBestVideoFormat = /* @__PURE__ */ __name(({ duration, formats, isLive }) => formats && formats.filter((f) => f.hasAudio && (duration < 10 * 60 || f.hasVideo) && (!isLive || f.isHLS)).sort((a, b) => Number(b.audioBitrate) - Number(a.audioBitrate) || Number(a.bitrate) - Number(b.bitrate))[0], "chooseBestVideoFormat");
var checked = process.env.NODE_ENV === "test";
var checkFFmpeg = /* @__PURE__ */ __name((distube) => {
  if (checked)
    return;
  const path = distube.options.ffmpeg.path;
  const debug = /* @__PURE__ */ __name((str) => distube.emit("ffmpegDebug" /* FFMPEG_DEBUG */, str), "debug");
  try {
    debug(`[test] spawn ffmpeg at '${path}' path`);
    const process2 = (0, import_child_process.spawnSync)(path, ["-h"], { windowsHide: true, shell: true, encoding: "utf-8" });
    if (process2.error)
      throw process2.error;
    if (process2.stderr && !process2.stdout)
      throw new Error(process2.stderr);
    const result = process2.output.join("\n");
    const version2 = /ffmpeg version (\S+)/iu.exec(result)?.[1];
    if (!version2)
      throw new Error("Invalid FFmpeg version");
    debug(`[test] ffmpeg version: ${version2}`);
    if (result.includes("--enable-libopus")) {
      debug("[test] ffmpeg supports libopus");
    } else {
      debug("[test] ffmpeg does not support libopus");
      distube.options.streamType = 1 /* RAW */;
    }
  } catch (e) {
    debug(`[test] failed to spawn ffmpeg at '${path}': ${e?.stack ?? e}`);
    throw new DisTubeError("FFMPEG_NOT_INSTALLED", path);
  }
  checked = true;
}, "checkFFmpeg");
var _DisTubeStream = class _DisTubeStream extends import_tiny_typed_emitter2.TypedEmitter {
  /**
   * Create a DisTubeStream to play with {@link DisTubeVoice}
   *
   * @param url     - Stream URL
   * @param options - Stream options
   */
  constructor(url, { ffmpeg, seek, type }) {
    super();
    __publicField(this, "killed", false);
    __publicField(this, "process");
    __publicField(this, "stream");
    __publicField(this, "type");
    __publicField(this, "url");
    this.url = url;
    this.type = !type ? import_voice2.StreamType.OggOpus : import_voice2.StreamType.Raw;
    const opts = {
      reconnect: 1,
      reconnect_streamed: 1,
      reconnect_delay_max: 5,
      analyzeduration: 0,
      hide_banner: true,
      ...ffmpeg.args.global,
      ...ffmpeg.args.input,
      i: url,
      ar: 48e3,
      ac: 2,
      ...ffmpeg.args.output
    };
    if (!type) {
      opts.f = "opus";
      opts.acodec = "libopus";
    } else {
      opts.f = "s16le";
    }
    if (typeof seek === "number" && seek > 0)
      opts.ss = seek.toString();
    this.process = (0, import_child_process.spawn)(
      ffmpeg.path,
      [
        ...Object.entries(opts).flatMap(
          ([key, value]) => Array.isArray(value) ? value.filter(Boolean).map((v) => [`-${key}`, String(v)]) : value == null || value === false ? [] : [value === true ? `-${key}` : [`-${key}`, String(value)]]
        ).flat(),
        "pipe:1"
      ],
      { stdio: ["ignore", "pipe", "pipe"], shell: false, windowsHide: true }
    ).on("error", (err) => {
      this.debug(`[process] error: ${err.message}`);
      this.emit("error", err);
    }).on("exit", (code, signal) => {
      this.debug(`[process] exit: code=${code ?? "unknown"} signal=${signal ?? "unknown"}`);
      if (!code || [0, 255].includes(code))
        return;
      this.debug(`[process] error: ffmpeg exited with code ${code}`);
      this.emit("error", new DisTubeError("FFMPEG_EXITED", code));
    });
    if (!this.process.stdout || !this.process.stderr) {
      this.kill();
      throw new Error("Failed to create ffmpeg process");
    }
    this.stream = new import_node_stream.PassThrough();
    this.stream.on("close", () => this.kill()).on("error", (err) => {
      this.debug(`[stream] error: ${err.message}`);
      this.emit("error", err);
    }).on("finish", () => this.debug("[stream] log: stream finished"));
    this.process.stdout.pipe(this.stream);
    this.process.stderr.setEncoding("utf8")?.on("data", (data) => {
      const lines = data.split(/\r\n|\r|\n/u);
      for (const line of lines) {
        if (/^\s*$/.test(line))
          continue;
        this.debug(`[ffmpeg] log: ${line}`);
      }
    });
  }
  debug(debug) {
    this.emit("debug", debug);
  }
  kill() {
    if (this.killed)
      return;
    this.process.kill("SIGKILL");
    this.killed = true;
  }
  /**
   * Create a stream from a YouTube {@link Song}
   *
   * @param song    - A YouTube Song
   * @param options - options
   */
  static YouTube(song, options) {
    if (song.source !== "youtube")
      throw new DisTubeError("INVALID_TYPE", "youtube", song.source, "Song#source");
    if (!song.formats?.length)
      throw new DisTubeError("UNAVAILABLE_VIDEO");
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new DisTubeError("INVALID_TYPE", "object", options, "options");
    }
    const bestFormat = chooseBestVideoFormat(song);
    if (!bestFormat)
      throw new DisTubeError("UNPLAYABLE_FORMATS");
    return new _DisTubeStream(bestFormat.url, options);
  }
  /**
   * Create a stream from a stream url
   *
   * @param url     - stream url
   * @param options - options
   */
  static DirectLink(url, options) {
    if (typeof url !== "string" || !isURL(url)) {
      throw new DisTubeError("INVALID_TYPE", "an URL", url);
    }
    if (!options || typeof options !== "object" || Array.isArray(options)) {
      throw new DisTubeError("INVALID_TYPE", "object", options, "options");
    }
    return new _DisTubeStream(url, options);
  }
};
__name(_DisTubeStream, "DisTubeStream");
var DisTubeStream = _DisTubeStream;

// src/core/DisTubeHandler.ts
var import_ytpl = __toESM(require("@distube/ytpl"));
var import_ytdl_core = __toESM(require("@distube/ytdl-core"));
var import_tough_cookie = require("tough-cookie");
var _cookie;
var _DisTubeHandler = class _DisTubeHandler extends DisTubeBase {
  constructor(distube) {
    super(distube);
    __privateAdd(this, _cookie, "");
    const client = this.client;
    if (this.options.leaveOnEmpty) {
      client.on("voiceStateUpdate", (oldState) => {
        if (!oldState?.channel)
          return;
        const queue = this.queues.get(oldState);
        if (!queue) {
          if (isVoiceChannelEmpty(oldState)) {
            setTimeout(() => {
              if (!this.queues.get(oldState) && isVoiceChannelEmpty(oldState))
                this.voices.leave(oldState);
            }, this.options.emptyCooldown * 1e3).unref();
          }
          return;
        }
        if (queue._emptyTimeout) {
          clearTimeout(queue._emptyTimeout);
          delete queue._emptyTimeout;
        }
        if (isVoiceChannelEmpty(oldState)) {
          queue._emptyTimeout = setTimeout(() => {
            delete queue._emptyTimeout;
            if (isVoiceChannelEmpty(oldState)) {
              queue.voice.leave();
              this.emit("empty" /* EMPTY */, queue);
              if (queue.stopped)
                queue.remove();
            }
          }, this.options.emptyCooldown * 1e3).unref();
        }
      });
    }
  }
  get ytdlOptions() {
    const options = this.options.ytdlOptions;
    if (this.options.youtubeCookie && this.options.youtubeCookie !== __privateGet(this, _cookie)) {
      const cookies = __privateSet(this, _cookie, this.options.youtubeCookie);
      if (typeof cookies === "string") {
        console.warn(
          "\x1B[33mWARNING:\x1B[0m You are using the old YouTube cookie format, please use the new one instead. (https://github.com/skick1234/DisTube/wiki/YouTube-Cookies)"
        );
        options.agent = import_ytdl_core.default.createAgent(
          cookies.split(";").map((c) => import_tough_cookie.Cookie.parse(c)).filter(isTruthy)
        );
      } else {
        options.agent = import_ytdl_core.default.createAgent(cookies);
      }
    }
    return options;
  }
  get ytCookie() {
    const agent = this.ytdlOptions.agent;
    if (!agent)
      return "";
    const { jar } = agent;
    return jar.getCookieStringSync("https://www.youtube.com");
  }
  /**
   * @param url   - url
   * @param basic - getBasicInfo?
   */
  getYouTubeInfo(url, basic = false) {
    if (basic)
      return import_ytdl_core.default.getBasicInfo(url, this.ytdlOptions);
    return import_ytdl_core.default.getInfo(url, this.ytdlOptions);
  }
  /**
   * Resolve a url or a supported object to a {@link Song} or {@link Playlist}
   *
   * @throws {@link DisTubeError}
   *
   * @param song    - URL | {@link Song}| {@link SearchResult} | {@link Playlist}
   * @param options - Optional options
   *
   * @returns Resolved
   */
  async resolve(song, options = {}) {
    if (song instanceof Song || song instanceof Playlist) {
      if ("metadata" in options)
        song.metadata = options.metadata;
      if ("member" in options)
        song.member = options.member;
      return song;
    }
    if (song instanceof SearchResultVideo)
      return new Song(song, options);
    if (song instanceof SearchResultPlaylist)
      return this.resolvePlaylist(song.url, options);
    if (isObject(song)) {
      if (!("url" in song) && !("id" in song))
        throw new DisTubeError("CANNOT_RESOLVE_SONG", song);
      return new Song(song, options);
    }
    if (import_ytpl.default.validateID(song))
      return this.resolvePlaylist(song, options);
    if (import_ytdl_core.default.validateURL(song))
      return new Song(await this.getYouTubeInfo(song, true), options);
    if (isURL(song)) {
      for (const plugin of this.distube.extractorPlugins) {
        if (await plugin.validate(song))
          return plugin.resolve(song, options);
      }
      throw new DisTubeError("NOT_SUPPORTED_URL");
    }
    throw new DisTubeError("CANNOT_RESOLVE_SONG", song);
  }
  /**
   * Resolve Song[] or YouTube playlist url to a Playlist
   *
   * @param playlist - Resolvable playlist
   * @param options  - Optional options
   */
  async resolvePlaylist(playlist, options = {}) {
    const { member, source, metadata } = { source: "youtube", ...options };
    if (playlist instanceof Playlist) {
      if ("metadata" in options)
        playlist.metadata = metadata;
      if ("member" in options)
        playlist.member = member;
      return playlist;
    }
    if (typeof playlist === "string") {
      const info = await (0, import_ytpl.default)(playlist, { limit: Infinity, requestOptions: { headers: { cookie: this.ytCookie } } });
      const songs = info.items.filter((v) => !v.thumbnail.includes("no_thumbnail")).map((v) => new Song(v, { member, metadata }));
      return new Playlist(
        {
          source,
          songs,
          member,
          name: info.title,
          url: info.url,
          thumbnail: songs[0].thumbnail
        },
        { metadata }
      );
    }
    return new Playlist(playlist, { member, properties: { source }, metadata });
  }
  /**
   * Search for a song, fire {@link DisTube#error} if not found.
   *
   * @throws {@link DisTubeError}
   *
   * @param message - The original message from an user
   * @param query   - The query string
   *
   * @returns Song info
   */
  async searchSong(message, query) {
    if (!isMessageInstance(message))
      throw new DisTubeError("INVALID_TYPE", "Discord.Message", message, "message");
    if (typeof query !== "string")
      throw new DisTubeError("INVALID_TYPE", "string", query, "query");
    if (query.length === 0)
      throw new DisTubeError("EMPTY_STRING", "query");
    const limit = this.options.searchSongs > 1 ? this.options.searchSongs : 1;
    const results = await this.distube.search(query, {
      limit,
      safeSearch: this.options.nsfw ? false : !isNsfwChannel(message.channel)
    }).catch(() => {
      if (!this.emit("searchNoResult" /* SEARCH_NO_RESULT */, message, query)) {
        console.warn("searchNoResult event does not have any listeners! Emits `error` event instead.");
        throw new DisTubeError("NO_RESULT");
      }
    });
    if (!results)
      return null;
    return this.createSearchMessageCollector(message, results, query);
  }
  /**
   * Create a message collector for selecting search results.
   *
   * Needed events: {@link DisTube#searchResult}, {@link DisTube#searchCancel},
   * {@link DisTube#searchInvalidAnswer}, {@link DisTube#searchDone}.
   *
   * @throws {@link DisTubeError}
   *
   * @param message - The original message from an user
   * @param results - The search results
   * @param query   - The query string
   *
   * @returns Selected result
   */
  async createSearchMessageCollector(message, results, query) {
    if (!isMessageInstance(message))
      throw new DisTubeError("INVALID_TYPE", "Discord.Message", message, "message");
    if (!Array.isArray(results) || results.length === 0) {
      throw new DisTubeError("INVALID_TYPE", "Array<SearchResult|Song|Playlist>", results, "results");
    }
    if (this.options.searchSongs > 1) {
      const searchEvents = [
        "searchNoResult" /* SEARCH_NO_RESULT */,
        "searchResult" /* SEARCH_RESULT */,
        "searchCancel" /* SEARCH_CANCEL */,
        "searchInvalidAnswer" /* SEARCH_INVALID_ANSWER */,
        "searchDone" /* SEARCH_DONE */
      ];
      for (const evn of searchEvents) {
        if (this.distube.listenerCount(evn) === 0) {
          console.warn(`"searchSongs" option is disabled due to missing "${evn}" listener.`);
          console.warn(
            `If you don't want to use "${evn}" event, simply add an empty listener (not recommended):
<DisTube>.on("${evn}", () => {})`
          );
          this.options.searchSongs = 0;
        }
      }
    }
    const limit = this.options.searchSongs > 1 ? this.options.searchSongs : 1;
    let result = results[0];
    if (limit > 1) {
      results.splice(limit);
      this.emit("searchResult" /* SEARCH_RESULT */, message, results, query);
      const answers = await message.channel.awaitMessages({
        filter: (m) => m.author.id === message.author.id,
        max: 1,
        time: this.options.searchCooldown * 1e3,
        errors: ["time"]
      }).catch(() => void 0);
      const ans = answers?.first();
      if (!ans) {
        this.emit("searchCancel" /* SEARCH_CANCEL */, message, query);
        return null;
      }
      const index = parseInt(ans.content, 10);
      if (isNaN(index) || index > results.length || index < 1) {
        this.emit("searchInvalidAnswer" /* SEARCH_INVALID_ANSWER */, message, ans, query);
        return null;
      }
      this.emit("searchDone" /* SEARCH_DONE */, message, ans, query);
      result = results[index - 1];
    }
    return result;
  }
  /**
   * Play or add a {@link Playlist} to the queue.
   *
   * @throws {@link DisTubeError}
   *
   * @param voiceChannel - A voice channel
   * @param playlist     - A YouTube playlist url | a Playlist
   * @param options      - Optional options
   */
  async playPlaylist(voiceChannel, playlist, options = {}) {
    const { textChannel, skip } = { skip: false, ...options };
    const position = Number(options.position) || (skip ? 1 : 0);
    if (!(playlist instanceof Playlist))
      throw new DisTubeError("INVALID_TYPE", "Playlist", playlist, "playlist");
    const queue = this.queues.get(voiceChannel);
    const isNsfw = isNsfwChannel(queue?.textChannel || textChannel);
    if (!this.options.nsfw && !isNsfw)
      playlist.songs = playlist.songs.filter((s) => !s.age_restricted);
    if (!playlist.songs.length) {
      if (!this.options.nsfw && !isNsfw)
        throw new DisTubeError("EMPTY_FILTERED_PLAYLIST");
      throw new DisTubeError("EMPTY_PLAYLIST");
    }
    if (queue) {
      if (this.options.joinNewVoiceChannel)
        queue.voice.channel = voiceChannel;
      queue.addToQueue(playlist.songs, position);
      if (skip)
        queue.skip();
      else
        this.emit("addList" /* ADD_LIST */, queue, playlist);
    } else {
      const newQueue = await this.queues.create(voiceChannel, playlist.songs, textChannel);
      if (newQueue instanceof Queue) {
        if (this.options.emitAddListWhenCreatingQueue)
          this.emit("addList" /* ADD_LIST */, newQueue, playlist);
        this.emit("playSong" /* PLAY_SONG */, newQueue, newQueue.songs[0]);
      }
    }
  }
  /**
   * Play or add a {@link Song} to the queue.
   *
   * @throws {@link DisTubeError}
   *
   * @param voiceChannel - A voice channel
   * @param song         - A YouTube playlist url | a Playlist
   * @param options      - Optional options
   */
  async playSong(voiceChannel, song, options = {}) {
    if (!(song instanceof Song))
      throw new DisTubeError("INVALID_TYPE", "Song", song, "song");
    const { textChannel, skip } = { skip: false, ...options };
    const position = Number(options.position) || (skip ? 1 : 0);
    const queue = this.queues.get(voiceChannel);
    if (!this.options.nsfw && song.age_restricted && !isNsfwChannel(queue?.textChannel || textChannel)) {
      throw new DisTubeError("NON_NSFW");
    }
    if (queue) {
      if (this.options.joinNewVoiceChannel)
        queue.voice.channel = voiceChannel;
      queue.addToQueue(song, position);
      if (skip)
        queue.skip();
      else
        this.emit("addSong" /* ADD_SONG */, queue, song);
    } else {
      const newQueue = await this.queues.create(voiceChannel, song, textChannel);
      if (newQueue instanceof Queue) {
        if (this.options.emitAddSongWhenCreatingQueue)
          this.emit("addSong" /* ADD_SONG */, newQueue, song);
        this.emit("playSong" /* PLAY_SONG */, newQueue, song);
      }
    }
  }
  /**
   * Get {@link Song}'s stream info and attach it to the song.
   *
   * @param song - A Song
   */
  async attachStreamInfo(song) {
    const { url, source } = song;
    if (source === "youtube") {
      song._patchYouTube(await this.handler.getYouTubeInfo(url));
    } else {
      for (const plugin of [...this.distube.extractorPlugins, ...this.distube.customPlugins]) {
        if (await plugin.validate(url)) {
          const info = [plugin.getStreamURL(url), plugin.getRelatedSongs(url)];
          const result = await Promise.all(info);
          song.streamURL = result[0];
          song.related = result[1];
          break;
        }
      }
    }
  }
};
_cookie = new WeakMap();
__name(_DisTubeHandler, "DisTubeHandler");
var DisTubeHandler = _DisTubeHandler;

// src/core/DisTubeOptions.ts
var _validateOptions, validateOptions_fn, _ffmpegOption, ffmpegOption_fn;
var _Options = class _Options {
  constructor(options) {
    __privateAdd(this, _validateOptions);
    __privateAdd(this, _ffmpegOption);
    __publicField(this, "plugins");
    __publicField(this, "emitNewSongOnly");
    __publicField(this, "leaveOnFinish");
    __publicField(this, "leaveOnStop");
    __publicField(this, "leaveOnEmpty");
    __publicField(this, "emptyCooldown");
    __publicField(this, "savePreviousSongs");
    __publicField(this, "searchSongs");
    __publicField(this, "searchCooldown");
    __publicField(this, "youtubeCookie");
    __publicField(this, "customFilters");
    __publicField(this, "ytdlOptions");
    __publicField(this, "nsfw");
    __publicField(this, "emitAddSongWhenCreatingQueue");
    __publicField(this, "emitAddListWhenCreatingQueue");
    __publicField(this, "joinNewVoiceChannel");
    __publicField(this, "streamType");
    __publicField(this, "directLink");
    /** @deprecated */
    __publicField(this, "ffmpegPath");
    /** @deprecated */
    __publicField(this, "ffmpegDefaultArgs");
    __publicField(this, "ffmpeg");
    if (typeof options !== "object" || Array.isArray(options)) {
      throw new DisTubeError("INVALID_TYPE", "object", options, "DisTubeOptions");
    }
    const opts = { ...defaultOptions, ...options };
    this.plugins = opts.plugins;
    this.emitNewSongOnly = opts.emitNewSongOnly;
    this.leaveOnEmpty = opts.leaveOnEmpty;
    this.leaveOnFinish = opts.leaveOnFinish;
    this.leaveOnStop = opts.leaveOnStop;
    this.savePreviousSongs = opts.savePreviousSongs;
    this.searchSongs = opts.searchSongs;
    this.youtubeCookie = opts.youtubeCookie;
    this.customFilters = opts.customFilters;
    this.ytdlOptions = opts.ytdlOptions;
    this.searchCooldown = opts.searchCooldown;
    this.emptyCooldown = opts.emptyCooldown;
    this.nsfw = opts.nsfw;
    this.emitAddSongWhenCreatingQueue = opts.emitAddSongWhenCreatingQueue;
    this.emitAddListWhenCreatingQueue = opts.emitAddListWhenCreatingQueue;
    this.joinNewVoiceChannel = opts.joinNewVoiceChannel;
    this.streamType = opts.streamType;
    this.directLink = opts.directLink;
    this.ffmpeg = __privateMethod(this, _ffmpegOption, ffmpegOption_fn).call(this, options);
    checkInvalidKey(opts, this, "DisTubeOptions");
    __privateMethod(this, _validateOptions, validateOptions_fn).call(this);
  }
};
_validateOptions = new WeakSet();
validateOptions_fn = /* @__PURE__ */ __name(function(options = this) {
  const booleanOptions = /* @__PURE__ */ new Set([
    "emitNewSongOnly",
    "leaveOnEmpty",
    "leaveOnFinish",
    "leaveOnStop",
    "savePreviousSongs",
    "joinNewVoiceChannel",
    "nsfw",
    "emitAddSongWhenCreatingQueue",
    "emitAddListWhenCreatingQueue",
    "directLink"
  ]);
  const numberOptions = /* @__PURE__ */ new Set(["searchCooldown", "emptyCooldown", "searchSongs"]);
  const stringOptions = /* @__PURE__ */ new Set();
  const objectOptions = /* @__PURE__ */ new Set(["customFilters", "ytdlOptions", "ffmpeg"]);
  const optionalOptions = /* @__PURE__ */ new Set(["youtubeCookie", "customFilters"]);
  for (const [key, value] of Object.entries(options)) {
    if (value === void 0 && optionalOptions.has(key))
      continue;
    if (key === "youtubeCookie" && !Array.isArray(value) && typeof value !== "string") {
      throw new DisTubeError("INVALID_TYPE", ["Array<Cookie>", "string"], value, `DisTubeOptions.${key}`);
    } else if (key === "streamType" && (typeof value !== "number" || isNaN(value) || !StreamType[value])) {
      throw new DisTubeError("INVALID_TYPE", "StreamType", value, `DisTubeOptions.${key}`);
    } else if (key === "plugins" && !Array.isArray(value)) {
      throw new DisTubeError("INVALID_TYPE", "Array<Plugin>", value, `DisTubeOptions.${key}`);
    } else if (booleanOptions.has(key)) {
      if (typeof value !== "boolean") {
        throw new DisTubeError("INVALID_TYPE", "boolean", value, `DisTubeOptions.${key}`);
      }
    } else if (numberOptions.has(key)) {
      if (typeof value !== "number" || isNaN(value)) {
        throw new DisTubeError("INVALID_TYPE", "number", value, `DisTubeOptions.${key}`);
      }
    } else if (stringOptions.has(key)) {
      if (typeof value !== "string") {
        throw new DisTubeError("INVALID_TYPE", "string", value, `DisTubeOptions.${key}`);
      }
    } else if (objectOptions.has(key)) {
      if (typeof value !== "object" || Array.isArray(value)) {
        throw new DisTubeError("INVALID_TYPE", "object", value, `DisTubeOptions.${key}`);
      }
    }
  }
}, "#validateOptions");
_ffmpegOption = new WeakSet();
ffmpegOption_fn = /* @__PURE__ */ __name(function(opts) {
  let path;
  const args = { global: {}, input: {}, output: {} };
  if (opts.ffmpegPath) {
    console.warn("`DisTubeOptions.ffmpegPath` is deprecated. Use `ffmpeg.path` instead.");
    path = opts.ffmpegPath;
  }
  if (opts.ffmpegDefaultArgs) {
    console.warn("`DisTubeOptions.ffmpegDefaultArgs` is deprecated. Use `ffmpeg.args` instead.");
    args.global = opts.ffmpegDefaultArgs;
  }
  path ??= opts.ffmpeg?.path ?? "ffmpeg";
  if (opts.ffmpeg?.args) {
    if (opts.ffmpeg.args.global)
      args.global = opts.ffmpeg.args.global;
    if (opts.ffmpeg.args.input)
      args.input = opts.ffmpeg.args.input;
    if (opts.ffmpeg.args.output)
      args.output = opts.ffmpeg.args.output;
  }
  return { path, args };
}, "#ffmpegOption");
__name(_Options, "Options");
var Options = _Options;

// src/core/manager/BaseManager.ts
var import_discord2 = require("discord.js");
var _BaseManager = class _BaseManager extends DisTubeBase {
  constructor() {
    super(...arguments);
    /**
     * The collection of items for this manager.
     */
    __publicField(this, "collection", new import_discord2.Collection());
  }
  /**
   * The size of the collection.
   */
  get size() {
    return this.collection.size;
  }
};
__name(_BaseManager, "BaseManager");
var BaseManager = _BaseManager;

// src/core/manager/GuildIdManager.ts
var _GuildIdManager = class _GuildIdManager extends BaseManager {
  add(idOrInstance, data) {
    const id = resolveGuildId(idOrInstance);
    const existing = this.get(id);
    if (existing)
      return this;
    this.collection.set(id, data);
    return this;
  }
  get(idOrInstance) {
    return this.collection.get(resolveGuildId(idOrInstance));
  }
  remove(idOrInstance) {
    return this.collection.delete(resolveGuildId(idOrInstance));
  }
  has(idOrInstance) {
    return this.collection.has(resolveGuildId(idOrInstance));
  }
};
__name(_GuildIdManager, "GuildIdManager");
var GuildIdManager = _GuildIdManager;

// src/core/manager/DisTubeVoiceManager.ts
var import_voice3 = require("@discordjs/voice");
var _DisTubeVoiceManager = class _DisTubeVoiceManager extends GuildIdManager {
  /**
   * Get a {@link DisTubeVoice}.
   *
   * @param guild - The queue resolvable to resolve
   */
  /**
   * Collection of {@link DisTubeVoice}.
   */
  /**
   * Create a {@link DisTubeVoice}
   *
   * @param channel - A voice channel to join
   */
  create(channel) {
    const existing = this.get(channel.guildId);
    if (existing) {
      existing.channel = channel;
      return existing;
    }
    return new DisTubeVoice(this, channel);
  }
  /**
   * Join a voice channel
   *
   * @param channel - A voice channel to join
   */
  join(channel) {
    const existing = this.get(channel.guildId);
    if (existing)
      return existing.join(channel);
    return this.create(channel).join();
  }
  /**
   * Leave the connected voice channel in a guild
   *
   * @param guild - Queue Resolvable
   */
  leave(guild) {
    const voice = this.get(guild);
    if (voice) {
      voice.leave();
    } else {
      const connection = (0, import_voice3.getVoiceConnection)(resolveGuildId(guild), this.client.user?.id) ?? (0, import_voice3.getVoiceConnection)(resolveGuildId(guild));
      if (connection && connection.state.status !== import_voice3.VoiceConnectionStatus.Destroyed) {
        connection.destroy();
      }
    }
  }
};
__name(_DisTubeVoiceManager, "DisTubeVoiceManager");
var DisTubeVoiceManager = _DisTubeVoiceManager;

// src/core/manager/FilterManager.ts
var _resolve, resolve_fn, _apply, apply_fn, _removeFn, removeFn_fn;
var _FilterManager = class _FilterManager extends BaseManager {
  constructor(queue) {
    super(queue.distube);
    __privateAdd(this, _resolve);
    __privateAdd(this, _apply);
    __privateAdd(this, _removeFn);
    /**
     * Collection of {@link Filter}.
     */
    __publicField(this, "queue");
    this.queue = queue;
  }
  /**
   * Enable a filter or multiple filters to the manager
   *
   * @param filterOrFilters - The filter or filters to enable
   * @param override        - Wether or not override the applied filter with new filter value
   */
  add(filterOrFilters, override = false) {
    if (Array.isArray(filterOrFilters)) {
      for (const filter of filterOrFilters) {
        const ft = __privateMethod(this, _resolve, resolve_fn).call(this, filter);
        if (override || !this.has(ft))
          this.collection.set(ft.name, ft);
      }
    } else {
      const ft = __privateMethod(this, _resolve, resolve_fn).call(this, filterOrFilters);
      if (override || !this.has(ft))
        this.collection.set(ft.name, ft);
    }
    __privateMethod(this, _apply, apply_fn).call(this);
    return this;
  }
  /**
   * Clear enabled filters of the manager
   */
  clear() {
    return this.set([]);
  }
  /**
   * Set the filters applied to the manager
   *
   * @param filters - The filters to apply
   */
  set(filters) {
    if (!Array.isArray(filters))
      throw new DisTubeError("INVALID_TYPE", "Array<FilterResolvable>", filters, "filters");
    this.collection.clear();
    for (const f of filters) {
      const filter = __privateMethod(this, _resolve, resolve_fn).call(this, f);
      this.collection.set(filter.name, filter);
    }
    __privateMethod(this, _apply, apply_fn).call(this);
    return this;
  }
  /**
   * Disable a filter or multiple filters
   *
   * @param filterOrFilters - The filter or filters to disable
   */
  remove(filterOrFilters) {
    if (Array.isArray(filterOrFilters))
      filterOrFilters.forEach((f) => __privateMethod(this, _removeFn, removeFn_fn).call(this, f));
    else
      __privateMethod(this, _removeFn, removeFn_fn).call(this, filterOrFilters);
    __privateMethod(this, _apply, apply_fn).call(this);
    return this;
  }
  /**
   * Check whether a filter enabled or not
   *
   * @param filter - The filter to check
   */
  has(filter) {
    return this.collection.has(typeof filter === "string" ? filter : __privateMethod(this, _resolve, resolve_fn).call(this, filter).name);
  }
  /**
   * Array of enabled filter names
   */
  get names() {
    return [...this.collection.keys()];
  }
  /**
   * Array of enabled filters
   */
  get values() {
    return [...this.collection.values()];
  }
  get ffmpegArgs() {
    return this.size ? { af: this.values.map((f) => f.value).join(",") } : {};
  }
  toString() {
    return this.names.toString();
  }
};
_resolve = new WeakSet();
resolve_fn = /* @__PURE__ */ __name(function(filter) {
  if (typeof filter === "object" && typeof filter.name === "string" && typeof filter.value === "string") {
    return filter;
  }
  if (typeof filter === "string" && Object.prototype.hasOwnProperty.call(this.distube.filters, filter)) {
    return {
      name: filter,
      value: this.distube.filters[filter]
    };
  }
  throw new DisTubeError("INVALID_TYPE", "FilterResolvable", filter, "filter");
}, "#resolve");
_apply = new WeakSet();
apply_fn = /* @__PURE__ */ __name(function() {
  this.queue.beginTime = this.queue.currentTime;
  this.queues.playSong(this.queue);
}, "#apply");
_removeFn = new WeakSet();
removeFn_fn = /* @__PURE__ */ __name(function(f) {
  return this.collection.delete(__privateMethod(this, _resolve, resolve_fn).call(this, f).name);
}, "#removeFn");
__name(_FilterManager, "FilterManager");
var FilterManager = _FilterManager;

// src/core/manager/QueueManager.ts
var _voiceEventHandler, voiceEventHandler_fn, _emitPlaySong, emitPlaySong_fn, _handleSongFinish, handleSongFinish_fn, _handlePlayingError, handlePlayingError_fn;
var _QueueManager = class _QueueManager extends GuildIdManager {
  constructor() {
    super(...arguments);
    /**
     * Get a Queue from this QueueManager.
     *
     * @param guild - Resolvable thing from a guild
     */
    /**
     * Listen to DisTubeVoice events and handle the Queue
     *
     * @param queue - Queue
     */
    __privateAdd(this, _voiceEventHandler);
    /**
     * Whether or not emit playSong event
     *
     * @param queue - Queue
     */
    __privateAdd(this, _emitPlaySong);
    /**
     * Handle the queue when a Song finish
     *
     * @param queue - queue
     */
    __privateAdd(this, _handleSongFinish);
    /**
     * Handle error while playing
     *
     * @param queue - queue
     * @param error - error
     */
    __privateAdd(this, _handlePlayingError);
  }
  /**
   * Collection of {@link Queue}.
   */
  /**
   * Create a {@link Queue}
   *
   * @param channel     - A voice channel
   * @param song        - First song
   * @param textChannel - Default text channel
   *
   * @returns Returns `true` if encounter an error
   */
  async create(channel, song, textChannel) {
    if (this.has(channel.guildId))
      throw new DisTubeError("QUEUE_EXIST");
    const voice = this.voices.create(channel);
    const queue = new Queue(this.distube, voice, song, textChannel);
    await queue._taskQueue.queuing();
    try {
      checkFFmpeg(this.distube);
      await voice.join();
      __privateMethod(this, _voiceEventHandler, voiceEventHandler_fn).call(this, queue);
      this.add(queue.id, queue);
      this.emit("initQueue" /* INIT_QUEUE */, queue);
      const err = await this.playSong(queue);
      return err || queue;
    } finally {
      queue._taskQueue.resolve();
    }
  }
  /**
   * Create a ytdl stream
   *
   * @param queue - Queue
   */
  createStream(queue) {
    const song = queue.songs[0];
    const { duration, source, streamURL } = song;
    const streamOptions = {
      ffmpeg: {
        path: this.options.ffmpeg.path,
        args: {
          global: { ...this.options.ffmpeg.args.global },
          input: { ...this.options.ffmpeg.args.input },
          output: { ...this.options.ffmpeg.args.output, ...queue.filters.ffmpegArgs }
        }
      },
      seek: duration ? queue.beginTime : void 0,
      type: this.options.streamType
    };
    if (source === "youtube")
      return DisTubeStream.YouTube(song, streamOptions);
    if (!streamURL)
      throw new Error("No streamURL, something went wrong");
    return DisTubeStream.DirectLink(streamURL, streamOptions);
  }
  /**
   * Play a song on voice connection
   *
   * @param queue - The guild queue
   *
   * @returns error?
   */
  async playSong(queue) {
    if (!queue)
      return true;
    if (queue.stopped || !queue.songs.length) {
      queue.stop();
      return true;
    }
    try {
      const song = queue.songs[0];
      await this.handler.attachStreamInfo(song);
      if (queue.stopped || !queue.songs.length) {
        queue.stop();
        return true;
      }
      const stream = this.createStream(queue);
      stream.on("debug", (data) => this.emit("ffmpegDebug" /* FFMPEG_DEBUG */, `[${queue.id}]: ${data}`));
      queue.voice.play(stream);
      song.streamURL = stream.url;
      return false;
    } catch (e) {
      __privateMethod(this, _handlePlayingError, handlePlayingError_fn).call(this, queue, e);
      return true;
    }
  }
};
_voiceEventHandler = new WeakSet();
voiceEventHandler_fn = /* @__PURE__ */ __name(function(queue) {
  queue._listeners = {
    disconnect: (error) => {
      queue.remove();
      this.emit("disconnect" /* DISCONNECT */, queue);
      if (error)
        this.emitError(error, queue.textChannel);
    },
    error: (error) => __privateMethod(this, _handlePlayingError, handlePlayingError_fn).call(this, queue, error),
    finish: () => __privateMethod(this, _handleSongFinish, handleSongFinish_fn).call(this, queue)
  };
  for (const event of objectKeys(queue._listeners)) {
    queue.voice.on(event, queue._listeners[event]);
  }
}, "#voiceEventHandler");
_emitPlaySong = new WeakSet();
emitPlaySong_fn = /* @__PURE__ */ __name(function(queue) {
  return !this.options.emitNewSongOnly || queue.repeatMode === 1 /* SONG */ && queue._next || queue.repeatMode !== 1 /* SONG */ && queue.songs[0]?.id !== queue.songs[1]?.id;
}, "#emitPlaySong");
_handleSongFinish = new WeakSet();
handleSongFinish_fn = /* @__PURE__ */ __name(async function(queue) {
  this.emit("finishSong" /* FINISH_SONG */, queue, queue.songs[0]);
  await queue._taskQueue.queuing();
  try {
    if (queue.stopped)
      return;
    if (queue.repeatMode === 2 /* QUEUE */ && !queue._prev)
      queue.songs.push(queue.songs[0]);
    if (queue._prev) {
      if (queue.repeatMode === 2 /* QUEUE */)
        queue.songs.unshift(queue.songs.pop());
      else
        queue.songs.unshift(queue.previousSongs.pop());
    }
    if (queue.songs.length <= 1 && (queue._next || queue.repeatMode === 0 /* DISABLED */)) {
      if (queue.autoplay) {
        try {
          await queue.addRelatedSong();
        } catch {
          this.emit("noRelated" /* NO_RELATED */, queue);
        }
      }
      if (queue.songs.length <= 1) {
        if (this.options.leaveOnFinish)
          queue.voice.leave();
        if (!queue.autoplay)
          this.emit("finish" /* FINISH */, queue);
        queue.remove();
        return;
      }
    }
    const emitPlaySong = __privateMethod(this, _emitPlaySong, emitPlaySong_fn).call(this, queue);
    if (!queue._prev && (queue.repeatMode !== 1 /* SONG */ || queue._next)) {
      const prev = queue.songs.shift();
      delete prev.formats;
      delete prev.streamURL;
      if (this.options.savePreviousSongs)
        queue.previousSongs.push(prev);
      else
        queue.previousSongs.push({ id: prev.id });
    }
    queue._next = queue._prev = false;
    queue.beginTime = 0;
    const err = await this.playSong(queue);
    if (!err && emitPlaySong)
      this.emit("playSong" /* PLAY_SONG */, queue, queue.songs[0]);
  } finally {
    queue._taskQueue.resolve();
  }
}, "#handleSongFinish");
_handlePlayingError = new WeakSet();
handlePlayingError_fn = /* @__PURE__ */ __name(function(queue, error) {
  const song = queue.songs.shift();
  try {
    error.name = "PlayingError";
    error.message = `${error.message}
Id: ${song.id}
Name: ${song.name}`;
  } catch {
  }
  this.emitError(error, queue.textChannel);
  if (queue.songs.length > 0) {
    queue._next = queue._prev = false;
    queue.beginTime = 0;
    this.playSong(queue).then((e) => {
      if (!e)
        this.emit("playSong" /* PLAY_SONG */, queue, queue.songs[0]);
    });
  } else {
    queue.stop();
  }
}, "#handlePlayingError");
__name(_QueueManager, "QueueManager");
var QueueManager = _QueueManager;

// src/struct/Queue.ts
var _filters;
var _Queue = class _Queue extends DisTubeBase {
  /**
   * Create a queue for the guild
   *
   * @param distube     - DisTube
   * @param voice       - Voice connection
   * @param song        - First song(s)
   * @param textChannel - Default text channel
   */
  constructor(distube, voice, song, textChannel) {
    super(distube);
    __publicField(this, "id");
    __publicField(this, "voice");
    __publicField(this, "songs");
    __publicField(this, "previousSongs");
    __publicField(this, "stopped");
    __publicField(this, "_next");
    __publicField(this, "_prev");
    __publicField(this, "playing");
    __publicField(this, "paused");
    __publicField(this, "repeatMode");
    __publicField(this, "autoplay");
    __privateAdd(this, _filters, void 0);
    __publicField(this, "beginTime");
    __publicField(this, "textChannel");
    __publicField(this, "_emptyTimeout");
    __publicField(this, "_taskQueue");
    __publicField(this, "_listeners");
    this.voice = voice;
    this.id = voice.id;
    this.volume = 50;
    this.songs = Array.isArray(song) ? [...song] : [song];
    this.previousSongs = [];
    this.stopped = false;
    this._next = false;
    this._prev = false;
    this.playing = true;
    this.paused = false;
    this.repeatMode = 0 /* DISABLED */;
    this.autoplay = false;
    __privateSet(this, _filters, new FilterManager(this));
    this.beginTime = 0;
    this.textChannel = textChannel;
    this._emptyTimeout = void 0;
    this._taskQueue = new TaskQueue();
    this._listeners = void 0;
  }
  /**
   * The client user as a `GuildMember` of this queue's guild
   */
  get clientMember() {
    return this.voice.channel.guild.members.me ?? void 0;
  }
  /**
   * The filter manager of the queue
   */
  get filters() {
    return __privateGet(this, _filters);
  }
  /**
   * Formatted duration string.
   */
  get formattedDuration() {
    return formatDuration(this.duration);
  }
  /**
   * Queue's duration.
   */
  get duration() {
    return this.songs.length ? this.songs.reduce((prev, next) => prev + next.duration, 0) : 0;
  }
  /**
   * What time in the song is playing (in seconds).
   */
  get currentTime() {
    return this.voice.playbackDuration + this.beginTime;
  }
  /**
   * Formatted {@link Queue#currentTime} string.
   */
  get formattedCurrentTime() {
    return formatDuration(this.currentTime);
  }
  /**
   * The voice channel playing in.
   */
  get voiceChannel() {
    return this.clientMember?.voice?.channel ?? null;
  }
  get volume() {
    return this.voice.volume;
  }
  set volume(value) {
    this.voice.volume = value;
  }
  /**
   * @throws {DisTubeError}
   *
   * @param song     - Song to add
   * @param position - Position to add, \<= 0 to add to the end of the queue
   *
   * @returns The guild queue
   */
  addToQueue(song, position = 0) {
    if (!song || Array.isArray(song) && !song.length) {
      throw new DisTubeError("INVALID_TYPE", ["Song", "Array<Song>"], song, "song");
    }
    if (typeof position !== "number" || !Number.isInteger(position)) {
      throw new DisTubeError("INVALID_TYPE", "integer", position, "position");
    }
    if (position <= 0) {
      if (Array.isArray(song))
        this.songs.push(...song);
      else
        this.songs.push(song);
    } else if (Array.isArray(song)) {
      this.songs.splice(position, 0, ...song);
    } else {
      this.songs.splice(position, 0, song);
    }
    if (Array.isArray(song))
      song.forEach((s) => delete s.formats);
    else
      delete song.formats;
    return this;
  }
  /**
   * Pause the guild stream
   *
   * @returns The guild queue
   */
  pause() {
    if (this.paused)
      throw new DisTubeError("PAUSED");
    this.playing = false;
    this.paused = true;
    this.voice.pause();
    return this;
  }
  /**
   * Resume the guild stream
   *
   * @returns The guild queue
   */
  resume() {
    if (this.playing)
      throw new DisTubeError("RESUMED");
    this.playing = true;
    this.paused = false;
    this.voice.unpause();
    return this;
  }
  /**
   * Set the guild stream's volume
   *
   * @param percent - The percentage of volume you want to set
   *
   * @returns The guild queue
   */
  setVolume(percent) {
    this.volume = percent;
    return this;
  }
  /**
   * Skip the playing song if there is a next song in the queue. <info>If {@link
   * Queue#autoplay} is `true` and there is no up next song, DisTube will add and
   * play a related song.</info>
   *
   * @returns The song will skip to
   */
  async skip() {
    await this._taskQueue.queuing();
    try {
      if (this.songs.length <= 1) {
        if (this.autoplay)
          await this.addRelatedSong();
        else
          throw new DisTubeError("NO_UP_NEXT");
      }
      const song = this.songs[1];
      this._next = true;
      this.voice.stop();
      return song;
    } finally {
      this._taskQueue.resolve();
    }
  }
  /**
   * Play the previous song if exists
   *
   * @returns The guild queue
   */
  async previous() {
    await this._taskQueue.queuing();
    try {
      if (!this.options.savePreviousSongs)
        throw new DisTubeError("DISABLED_OPTION", "savePreviousSongs");
      if (this.previousSongs?.length === 0 && this.repeatMode !== 2 /* QUEUE */) {
        throw new DisTubeError("NO_PREVIOUS");
      }
      const song = this.repeatMode === 2 ? this.songs[this.songs.length - 1] : this.previousSongs[this.previousSongs.length - 1];
      this._prev = true;
      this.voice.stop();
      return song;
    } finally {
      this._taskQueue.resolve();
    }
  }
  /**
   * Shuffle the queue's songs
   *
   * @returns The guild queue
   */
  async shuffle() {
    await this._taskQueue.queuing();
    try {
      const playing = this.songs.shift();
      if (playing === void 0)
        return this;
      for (let i = this.songs.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [this.songs[i], this.songs[j]] = [this.songs[j], this.songs[i]];
      }
      this.songs.unshift(playing);
      return this;
    } finally {
      this._taskQueue.resolve();
    }
  }
  /**
   * Jump to the song position in the queue. The next one is 1, 2,... The previous
   * one is -1, -2,...
   * if `num` is invalid number
   *
   * @param position - The song position to play
   *
   * @returns The new Song will be played
   */
  async jump(position) {
    await this._taskQueue.queuing();
    try {
      if (typeof position !== "number")
        throw new DisTubeError("INVALID_TYPE", "number", position, "position");
      if (!position || position > this.songs.length || -position > this.previousSongs.length) {
        throw new DisTubeError("NO_SONG_POSITION");
      }
      let nextSong;
      if (position > 0) {
        const nextSongs = this.songs.splice(position - 1);
        if (this.options.savePreviousSongs) {
          this.previousSongs.push(...this.songs);
        } else {
          this.previousSongs.push(...this.songs.map((s) => ({ id: s.id })));
        }
        this.songs = nextSongs;
        this._next = true;
        nextSong = nextSongs[1];
      } else if (!this.options.savePreviousSongs) {
        throw new DisTubeError("DISABLED_OPTION", "savePreviousSongs");
      } else {
        this._prev = true;
        if (position !== -1)
          this.songs.unshift(...this.previousSongs.splice(position + 1));
        nextSong = this.previousSongs[this.previousSongs.length - 1];
      }
      this.voice.stop();
      return nextSong;
    } finally {
      this._taskQueue.resolve();
    }
  }
  /**
   * Set the repeat mode of the guild queue.
   * Toggle mode `(Disabled -> Song -> Queue -> Disabled ->...)` if `mode` is `undefined`
   *
   * @param mode - The repeat modes (toggle if `undefined`)
   *
   * @returns The new repeat mode
   */
  setRepeatMode(mode) {
    if (mode !== void 0 && !Object.values(RepeatMode).includes(mode)) {
      throw new DisTubeError("INVALID_TYPE", ["RepeatMode", "undefined"], mode, "mode");
    }
    if (mode === void 0)
      this.repeatMode = (this.repeatMode + 1) % 3;
    else if (this.repeatMode === mode)
      this.repeatMode = 0 /* DISABLED */;
    else
      this.repeatMode = mode;
    return this.repeatMode;
  }
  /**
   * Set the playing time to another position
   *
   * @param time - Time in seconds
   *
   * @returns The guild queue
   */
  seek(time) {
    if (typeof time !== "number")
      throw new DisTubeError("INVALID_TYPE", "number", time, "time");
    if (isNaN(time) || time < 0)
      throw new DisTubeError("NUMBER_COMPARE", "time", "bigger or equal to", 0);
    this.beginTime = time;
    this.queues.playSong(this);
    return this;
  }
  /**
   * Add a related song of the playing song to the queue
   *
   * @returns The added song
   */
  async addRelatedSong() {
    if (!this.songs?.[0])
      throw new DisTubeError("NO_PLAYING");
    const related = this.songs[0].related.find((v) => !this.previousSongs.map((s) => s.id).includes(v.id));
    if (!related || !(related instanceof Song))
      throw new DisTubeError("NO_RELATED");
    const song = await this.handler.resolve(related, { member: this.clientMember, metadata: related.metadata });
    if (!(song instanceof Song))
      throw new DisTubeError("CANNOT_PLAY_RELATED");
    this.addToQueue(song);
    return song;
  }
  /**
   * Stop the guild stream and delete the queue
   */
  async stop() {
    await this._taskQueue.queuing();
    try {
      this.playing = false;
      this.paused = false;
      this.stopped = true;
      if (this.options.leaveOnStop)
        this.voice.leave();
      else
        this.voice.stop();
      this.remove();
    } finally {
      this._taskQueue.resolve();
    }
  }
  /**
   * Remove the queue from the manager (This does not leave the voice channel even if
   * {@link DisTubeOptions | DisTubeOptions.leaveOnStop} is enabled)
   */
  remove() {
    this.stopped = true;
    this.songs = [];
    this.previousSongs = [];
    if (this._listeners) {
      for (const event of objectKeys(this._listeners)) {
        this.voice.removeListener(event, this._listeners[event]);
      }
    }
    this.queues.remove(this.id);
    this.emit("deleteQueue" /* DELETE_QUEUE */, this);
  }
  /**
   * Toggle autoplay mode
   *
   * @returns Autoplay mode state
   */
  toggleAutoplay() {
    this.autoplay = !this.autoplay;
    return this.autoplay;
  }
};
_filters = new WeakMap();
__name(_Queue, "Queue");
var Queue = _Queue;

// src/struct/Plugin.ts
var _Plugin = class _Plugin {
  constructor() {
    __publicField(this, "distube");
  }
  init(distube) {
    this.distube = distube;
  }
  /**
   * Type of the plugin
   */
  /**
   * Emit an event to the {@link DisTube} class
   *
   * @param eventName - Event name
   * @param args      - arguments
   */
  emit(eventName, ...args) {
    return this.distube.emit(eventName, ...args);
  }
  /**
   * Emit error event to the {@link DisTube} class
   *
   * @param error   - error
   * @param channel - Text channel where the error is encountered.
   */
  emitError(error, channel) {
    this.distube.emitError(error, channel);
  }
  /**
   * The queue manager
   */
  get queues() {
    return this.distube.queues;
  }
  /**
   * The voice manager
   */
  get voices() {
    return this.distube.voices;
  }
  /**
   * Discord.js client
   */
  get client() {
    return this.distube.client;
  }
  /**
   * DisTube options
   */
  get options() {
    return this.distube.options;
  }
  /**
   * DisTube handler
   */
  get handler() {
    return this.distube.handler;
  }
  /**
   * Check if the string is working with this plugin
   *
   * @param _string - Input string
   */
  validate(_string) {
    return false;
  }
  /**
   * Get the stream url from {@link Song#url}. Returns {@link Song#url} by default.
   * Not needed if the plugin plays song from YouTube.
   *
   * @param url - Input url
   */
  getStreamURL(url) {
    return url;
  }
  /**
   * Get related songs from a supported url. {@link Song#member} should be
   * `undefined`. Not needed to add {@link Song#related} because it will be added
   * with this function later.
   *
   * @param _url - Input url
   */
  getRelatedSongs(_url) {
    return [];
  }
};
__name(_Plugin, "Plugin");
var Plugin = _Plugin;

// src/struct/CustomPlugin.ts
var _CustomPlugin = class _CustomPlugin extends Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "custom" /* CUSTOM */);
  }
};
__name(_CustomPlugin, "CustomPlugin");
var CustomPlugin = _CustomPlugin;

// src/struct/ExtractorPlugin.ts
var _ExtractorPlugin = class _ExtractorPlugin extends Plugin {
  constructor() {
    super(...arguments);
    __publicField(this, "type", "extractor" /* EXTRACTOR */);
  }
};
__name(_ExtractorPlugin, "ExtractorPlugin");
var ExtractorPlugin = _ExtractorPlugin;

// src/util.ts
var import_url = require("url");
var import_discord3 = require("discord.js");
var formatInt = /* @__PURE__ */ __name((int) => int < 10 ? `0${int}` : int, "formatInt");
function formatDuration(sec) {
  if (!sec || !Number(sec))
    return "00:00";
  const seconds = Math.floor(sec % 60);
  const minutes = Math.floor(sec % 3600 / 60);
  const hours = Math.floor(sec / 3600);
  if (hours > 0)
    return `${formatInt(hours)}:${formatInt(minutes)}:${formatInt(seconds)}`;
  if (minutes > 0)
    return `${formatInt(minutes)}:${formatInt(seconds)}`;
  return `00:${formatInt(seconds)}`;
}
__name(formatDuration, "formatDuration");
function toSecond(input) {
  if (!input)
    return 0;
  if (typeof input !== "string")
    return Number(input) || 0;
  if (input.includes(":")) {
    const time = input.split(":").reverse();
    let seconds = 0;
    for (let i = 0; i < 3; i++)
      if (time[i])
        seconds += Number(time[i].replace(/[^\d.]+/g, "")) * Math.pow(60, i);
    if (time.length > 3)
      seconds += Number(time[3].replace(/[^\d.]+/g, "")) * 24 * 60 * 60;
    return seconds;
  } else {
    return Number(input.replace(/[^\d.]+/g, "")) || 0;
  }
}
__name(toSecond, "toSecond");
function parseNumber(input) {
  if (typeof input === "string")
    return Number(input.replace(/[^\d.]+/g, "")) || 0;
  return Number(input) || 0;
}
__name(parseNumber, "parseNumber");
var SUPPORTED_PROTOCOL = ["https:", "http:", "file:"];
function isURL(input) {
  if (typeof input !== "string" || input.includes(" "))
    return false;
  try {
    const url = new import_url.URL(input);
    if (!SUPPORTED_PROTOCOL.some((p) => p === url.protocol))
      return false;
  } catch {
    return false;
  }
  return true;
}
__name(isURL, "isURL");
function checkIntents(options) {
  const intents = new import_discord3.IntentsBitField(options.intents);
  if (!intents.has(import_discord3.GatewayIntentBits.GuildVoiceStates))
    throw new DisTubeError("MISSING_INTENTS", "GuildVoiceStates");
}
__name(checkIntents, "checkIntents");
function isVoiceChannelEmpty(voiceState) {
  const guild = voiceState.guild;
  const clientId = voiceState.client.user?.id;
  if (!guild || !clientId)
    return false;
  const voiceChannel = guild.members.me?.voice?.channel;
  if (!voiceChannel)
    return false;
  const members = voiceChannel.members.filter((m) => !m.user.bot);
  return !members.size;
}
__name(isVoiceChannelEmpty, "isVoiceChannelEmpty");
function isSnowflake(id) {
  try {
    return import_discord3.SnowflakeUtil.deconstruct(id).timestamp > import_discord3.SnowflakeUtil.epoch;
  } catch {
    return false;
  }
}
__name(isSnowflake, "isSnowflake");
function isMemberInstance(member) {
  return Boolean(member) && isSnowflake(member.id) && isSnowflake(member.guild?.id) && isSnowflake(member.user?.id) && member.id === member.user.id;
}
__name(isMemberInstance, "isMemberInstance");
function isTextChannelInstance(channel) {
  return Boolean(channel) && isSnowflake(channel.id) && isSnowflake(channel.guildId || channel.guild?.id) && import_discord3.Constants.TextBasedChannelTypes.includes(channel.type) && typeof channel.send === "function" && (typeof channel.nsfw === "boolean" || typeof channel.parent?.nsfw === "boolean");
}
__name(isTextChannelInstance, "isTextChannelInstance");
function isMessageInstance(message) {
  return Boolean(message) && isSnowflake(message.id) && isSnowflake(message.guildId || message.guild?.id) && isMemberInstance(message.member) && isTextChannelInstance(message.channel) && import_discord3.Constants.NonSystemMessageTypes.includes(message.type) && message.member.id === message.author?.id;
}
__name(isMessageInstance, "isMessageInstance");
function isSupportedVoiceChannel(channel) {
  return Boolean(channel) && isSnowflake(channel.id) && isSnowflake(channel.guildId || channel.guild?.id) && import_discord3.Constants.VoiceBasedChannelTypes.includes(channel.type);
}
__name(isSupportedVoiceChannel, "isSupportedVoiceChannel");
function isGuildInstance(guild) {
  return Boolean(guild) && isSnowflake(guild.id) && isSnowflake(guild.ownerId) && typeof guild.name === "string";
}
__name(isGuildInstance, "isGuildInstance");
function resolveGuildId(resolvable) {
  let guildId;
  if (typeof resolvable === "string") {
    guildId = resolvable;
  } else if (isObject(resolvable)) {
    if ("guildId" in resolvable && resolvable.guildId) {
      guildId = resolvable.guildId;
    } else if (resolvable instanceof Queue || resolvable instanceof DisTubeVoice || isGuildInstance(resolvable)) {
      guildId = resolvable.id;
    } else if ("guild" in resolvable && isGuildInstance(resolvable.guild)) {
      guildId = resolvable.guild.id;
    }
  }
  if (!isSnowflake(guildId))
    throw new DisTubeError("INVALID_TYPE", "GuildIdResolvable", resolvable);
  return guildId;
}
__name(resolveGuildId, "resolveGuildId");
function isClientInstance(client) {
  return Boolean(client) && typeof client.login === "function";
}
__name(isClientInstance, "isClientInstance");
function checkInvalidKey(target, source, sourceName) {
  if (!isObject(target))
    throw new DisTubeError("INVALID_TYPE", "object", target, sourceName);
  const sourceKeys = Array.isArray(source) ? source : objectKeys(source);
  const invalidKey = objectKeys(target).find((key) => !sourceKeys.includes(key));
  if (invalidKey)
    throw new DisTubeError("INVALID_KEY", sourceName, invalidKey);
}
__name(checkInvalidKey, "checkInvalidKey");
function isObject(obj) {
  return typeof obj === "object" && obj !== null && !Array.isArray(obj);
}
__name(isObject, "isObject");
function isRecord(obj) {
  return isObject(obj);
}
__name(isRecord, "isRecord");
function objectKeys(obj) {
  if (!isObject(obj))
    return [];
  return Object.keys(obj);
}
__name(objectKeys, "objectKeys");
function isNsfwChannel(channel) {
  if (!isTextChannelInstance(channel))
    return false;
  if (channel.isThread())
    return channel.parent?.nsfw ?? false;
  return channel.nsfw;
}
__name(isNsfwChannel, "isNsfwChannel");
var isTruthy = /* @__PURE__ */ __name((x) => Boolean(x), "isTruthy");

// src/plugin/DirectLink.ts
var import_undici = require("undici");
var _DirectLinkPlugin = class _DirectLinkPlugin extends ExtractorPlugin {
  async validate(url) {
    try {
      const headers = await (0, import_undici.request)(url, { method: "HEAD" }).then((res) => res.headers);
      const types = headers["content-type"];
      const type = Array.isArray(types) ? types[0] : types;
      if (["audio/", "video/", "application/ogg"].some((s) => type?.startsWith(s)))
        return true;
    } catch {
    }
    return false;
  }
  resolve(url, options = {}) {
    const u = new URL(url);
    const name = u.pathname.split("/").pop() || u.href;
    return new Song({ name, url, src: "direct_link" }, options);
  }
};
__name(_DirectLinkPlugin, "DirectLinkPlugin");
var DirectLinkPlugin = _DirectLinkPlugin;

// src/DisTube.ts
var import_ytsr = __toESM(require("@distube/ytsr"));
var import_tiny_typed_emitter3 = require("tiny-typed-emitter");
var { version } = require_package();
var _getQueue, getQueue_fn;
var _DisTube = class _DisTube extends import_tiny_typed_emitter3.TypedEmitter {
  constructor(client, opts = {}) {
    super();
    __privateAdd(this, _getQueue);
    __publicField(this, "handler");
    __publicField(this, "options");
    __publicField(this, "client");
    __publicField(this, "queues");
    __publicField(this, "voices");
    __publicField(this, "extractorPlugins");
    __publicField(this, "customPlugins");
    __publicField(this, "filters");
    this.setMaxListeners(1);
    if (!isClientInstance(client))
      throw new DisTubeError("INVALID_TYPE", "Discord.Client", client, "client");
    this.client = client;
    checkIntents(client.options);
    this.options = new Options(opts);
    this.voices = new DisTubeVoiceManager(this);
    this.handler = new DisTubeHandler(this);
    this.queues = new QueueManager(this);
    this.filters = { ...defaultFilters, ...this.options.customFilters };
    if (this.options.directLink)
      this.options.plugins.push(new DirectLinkPlugin());
    this.options.plugins.forEach((p) => p.init(this));
    this.extractorPlugins = this.options.plugins.filter((p) => p.type === "extractor");
    this.customPlugins = this.options.plugins.filter((p) => p.type === "custom");
  }
  static get version() {
    return version;
  }
  /**
   * DisTube version
   */
  get version() {
    return version;
  }
  /**
   * Play / add a song or playlist from url. Search and play a song if it is not a
   * valid url.
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "play")
   *         distube.play(message.member.voice.channel, args.join(" "), {
   *             member: message.member,
   *             textChannel: message.channel,
   *             message
   *         });
   * });
   * ```ts
   *
   * @throws {@link DisTubeError}
   *
   * @param voiceChannel - The channel will be joined if the bot isn't in any channels, the bot will be
   *                       moved to this channel if {@link DisTubeOptions}.joinNewVoiceChannel is `true`
   * @param song         - URL | Search string | {@link Song} | {@link SearchResult} | {@link Playlist}
   * @param options      - Optional options
   */
  async play(voiceChannel, song, options = {}) {
    if (!isSupportedVoiceChannel(voiceChannel)) {
      throw new DisTubeError("INVALID_TYPE", "BaseGuildVoiceChannel", voiceChannel, "voiceChannel");
    }
    if (!isObject(options))
      throw new DisTubeError("INVALID_TYPE", "object", options, "options");
    const { textChannel, member, skip, message, metadata } = {
      member: voiceChannel.guild.members.me ?? void 0,
      textChannel: options?.message?.channel,
      skip: false,
      ...options
    };
    const position = Number(options.position) || (skip ? 1 : 0);
    if (message && !isMessageInstance(message)) {
      throw new DisTubeError("INVALID_TYPE", ["Discord.Message", "a falsy value"], message, "options.message");
    }
    if (textChannel && !isTextChannelInstance(textChannel)) {
      throw new DisTubeError("INVALID_TYPE", "Discord.GuildTextBasedChannel", textChannel, "options.textChannel");
    }
    if (member && !isMemberInstance(member)) {
      throw new DisTubeError("INVALID_TYPE", "Discord.GuildMember", member, "options.member");
    }
    const queue = this.getQueue(voiceChannel);
    const queuing = queue && !queue._taskQueue.hasResolveTask;
    if (queuing)
      await queue?._taskQueue.queuing(true);
    try {
      if (typeof song === "string") {
        for (const plugin of this.customPlugins) {
          if (await plugin.validate(song)) {
            await plugin.play(voiceChannel, song, options);
            return;
          }
        }
      }
      if (typeof song === "string" && !isURL(song)) {
        if (!message) {
          song = (await this.search(song, { limit: 1 }))[0];
        } else {
          const result = await this.handler.searchSong(message, song);
          if (!result)
            return;
          song = result;
        }
      }
      song = await this.handler.resolve(song, { member, metadata });
      if (song instanceof Playlist) {
        await this.handler.playPlaylist(voiceChannel, song, { textChannel, skip, position });
      } else {
        await this.handler.playSong(voiceChannel, song, { textChannel, skip, position });
      }
    } catch (e) {
      if (!(e instanceof DisTubeError)) {
        try {
          e.name = "PlayError";
          e.message = `${typeof song === "string" ? song : song.url}
${e.message}`;
        } catch {
        }
      }
      throw e;
    } finally {
      if (queuing)
        queue?._taskQueue.resolve();
    }
  }
  /**
   * Create a custom playlist
   *
   * @example
   * ```ts
   * const songs = ["https://www.youtube.com/watch?v=xxx", "https://www.youtube.com/watch?v=yyy"];
   * const playlist = await distube.createCustomPlaylist(songs, {
   *     member: message.member,
   *     properties: { name: "My playlist name", source: "custom" },
   *     parallel: true
   * });
   * distube.play(voiceChannel, playlist, { ... });
   * ```ts
   *
   * @param songs   - Array of url, Song or SearchResult
   * @param options - Optional options
   */
  async createCustomPlaylist(songs, options = {}) {
    const { member, properties, parallel, metadata } = { parallel: true, ...options };
    if (!Array.isArray(songs))
      throw new DisTubeError("INVALID_TYPE", "Array", songs, "songs");
    if (!songs.length)
      throw new DisTubeError("EMPTY_ARRAY", "songs");
    const filteredSongs = songs.filter(
      (song) => song instanceof Song || isURL(song) || typeof song !== "string" && song.type === "video" /* VIDEO */
    );
    if (!filteredSongs.length)
      throw new DisTubeError("NO_VALID_SONG");
    if (member && !isMemberInstance(member)) {
      throw new DisTubeError("INVALID_TYPE", "Discord.Member", member, "options.member");
    }
    let resolvedSongs;
    if (parallel) {
      const promises = filteredSongs.map(
        (song) => this.handler.resolve(song, { member, metadata }).catch(() => void 0)
      );
      resolvedSongs = (await Promise.all(promises)).filter((s) => s instanceof Song);
    } else {
      resolvedSongs = [];
      for (const song of filteredSongs) {
        const resolved = await this.handler.resolve(song, { member, metadata }).catch(() => void 0);
        if (resolved instanceof Song)
          resolvedSongs.push(resolved);
      }
    }
    return new Playlist(resolvedSongs, { member, properties, metadata });
  }
  /**
   * Search for a song. You can customize how user answers instead of send a number.
   * Then use {@link DisTube#play} to play it.
   *
   * @param string             - The string search for
   * @param options            - Search options
   * @param options.limit      - Limit the results
   * @param options.type       - Type of results (`video` or `playlist`).
   * @param options.safeSearch - Whether or not use safe search (YouTube restricted mode)
   *
   * @returns Array of results
   */
  async search(string, options = {}) {
    const opts = { type: "video" /* VIDEO */, limit: 10, safeSearch: false, ...options };
    if (typeof opts.type !== "string" || !["video", "playlist"].includes(opts.type)) {
      throw new DisTubeError("INVALID_TYPE", ["video", "playlist"], opts.type, "options.type");
    }
    if (typeof opts.limit !== "number")
      throw new DisTubeError("INVALID_TYPE", "number", opts.limit, "options.limit");
    if (opts.limit < 1)
      throw new DisTubeError("NUMBER_COMPARE", "option.limit", "bigger or equal to", 1);
    if (typeof opts.safeSearch !== "boolean") {
      throw new DisTubeError("INVALID_TYPE", "boolean", opts.safeSearch, "options.safeSearch");
    }
    try {
      const search = await (0, import_ytsr.default)(string, { ...opts, requestOptions: { headers: { cookie: this.handler.ytCookie } } });
      const results = search.items.map((i) => {
        if (i.type === "video")
          return new SearchResultVideo(i);
        return new SearchResultPlaylist(i);
      });
      if (results.length === 0)
        throw new DisTubeError("NO_RESULT");
      return results;
    } catch (e) {
      if (options.retried)
        throw e;
      options.retried = true;
      return this.search(string, options);
    }
  }
  /**
   * Get the guild queue
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "queue") {
   *         const queue = distube.getQueue(message);
   *         message.channel.send('Current queue:\n' + queue.songs.map((song, id) =>
   *             `**${id+1}**. [${song.name}](${song.url}) - \`${song.formattedDuration}\``
   *         ).join("\n"));
   *     }
   * });
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   */
  getQueue(guild) {
    return this.queues.get(guild);
  }
  /**
   * Pause the guild stream
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   *
   * @returns The guild queue
   */
  pause(guild) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).pause();
  }
  /**
   * Resume the guild stream
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   *
   * @returns The guild queue
   */
  resume(guild) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).resume();
  }
  /**
   * Stop the guild stream
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "stop") {
   *         distube.stop(message);
   *         message.channel.send("Stopped the queue!");
   *     }
   * });
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   */
  stop(guild) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).stop();
  }
  /**
   * Set the guild stream's volume
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "volume")
   *         distube.setVolume(message, Number(args[0]));
   * });
   * ```ts
   *
   * @param guild   - The type can be resolved to give a {@link Queue}
   * @param percent - The percentage of volume you want to set
   *
   * @returns The guild queue
   */
  setVolume(guild, percent) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).setVolume(percent);
  }
  /**
   * Skip the playing song if there is a next song in the queue. <info>If {@link
   * Queue#autoplay} is `true` and there is no up next song, DisTube will add and
   * play a related song.</info>
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "skip")
   *         distube.skip(message);
   * });
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   *
   * @returns The new Song will be played
   */
  skip(guild) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).skip();
  }
  /**
   * Play the previous song
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "previous")
   *         distube.previous(message);
   * });
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   *
   * @returns The new Song will be played
   */
  previous(guild) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).previous();
  }
  /**
   * Shuffle the guild queue songs
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "shuffle")
   *         distube.shuffle(message);
   * });
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   *
   * @returns The guild queue
   */
  shuffle(guild) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).shuffle();
  }
  /**
   * Jump to the song number in the queue. The next one is 1, 2,... The previous one
   * is -1, -2,...
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "jump")
   *         distube.jump(message, parseInt(args[0]))
   *             .catch(err => message.channel.send("Invalid song number."));
   * });
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   * @param num   - The song number to play
   *
   * @returns The new Song will be played
   */
  jump(guild, num) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).jump(num);
  }
  /**
   * Set the repeat mode of the guild queue.
   * Toggle mode `(Disabled -> Song -> Queue -> Disabled ->...)` if `mode` is `undefined`
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "repeat") {
   *         let mode = distube.setRepeatMode(message, parseInt(args[0]));
   *         mode = mode ? mode == 2 ? "Repeat queue" : "Repeat song" : "Off";
   *         message.channel.send("Set repeat mode to `" + mode + "`");
   *     }
   * });
   * ```ts
   * @example
   * ```ts
   * const { RepeatMode } = require("distube");
   * let mode;
   * switch(distube.setRepeatMode(message, parseInt(args[0]))) {
   *     case RepeatMode.DISABLED:
   *         mode = "Off";
   *         break;
   *     case RepeatMode.SONG:
   *         mode = "Repeat a song";
   *         break;
   *     case RepeatMode.QUEUE:
   *         mode = "Repeat all queue";
   *         break;
   * }
   * message.channel.send("Set repeat mode to `" + mode + "`");
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   * @param mode  - The repeat modes (toggle if `undefined`)
   *
   * @returns The new repeat mode
   */
  setRepeatMode(guild, mode) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).setRepeatMode(mode);
  }
  /**
   * Toggle autoplay mode
   *
   * @example
   * ```ts
   * client.on('message', (message) => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command == "autoplay") {
   *         const mode = distube.toggleAutoplay(message);
   *         message.channel.send("Set autoplay mode to `" + (mode ? "On" : "Off") + "`");
   *     }
   * });
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   *
   * @returns Autoplay mode state
   */
  toggleAutoplay(guild) {
    const queue = __privateMethod(this, _getQueue, getQueue_fn).call(this, guild);
    queue.autoplay = !queue.autoplay;
    return queue.autoplay;
  }
  /**
   * Add related song to the queue
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   *
   * @returns The guild queue
   */
  addRelatedSong(guild) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).addRelatedSong();
  }
  /**
   * Set the playing time to another position
   *
   * @example
   * ```ts
   * client.on('message', message => {
   *     if (!message.content.startsWith(config.prefix)) return;
   *     const args = message.content.slice(config.prefix.length).trim().split(/ +/g);
   *     const command = args.shift();
   *     if (command = 'seek')
   *         distube.seek(message, Number(args[0]));
   * });
   * ```ts
   *
   * @param guild - The type can be resolved to give a {@link Queue}
   * @param time  - Time in seconds
   *
   * @returns Seeked queue
   */
  seek(guild, time) {
    return __privateMethod(this, _getQueue, getQueue_fn).call(this, guild).seek(time);
  }
  /**
   * Emit error event
   *
   * @param error   - error
   * @param channel - Text channel where the error is encountered.
   */
  emitError(error, channel) {
    if (this.listeners("error" /* ERROR */).length) {
      this.emit("error" /* ERROR */, channel, error);
    } else {
      console.error(error);
      console.warn("Unhandled 'error' event.");
      console.warn(
        "See: https://distube.js.org/classes/DisTube.html#error and https://nodejs.org/api/events.html#events_error_events"
      );
    }
  }
};
_getQueue = new WeakSet();
getQueue_fn = /* @__PURE__ */ __name(function(guild) {
  const queue = this.getQueue(guild);
  if (!queue)
    throw new DisTubeError("NO_QUEUE");
  return queue;
}, "#getQueue");
__name(_DisTube, "DisTube");
var DisTube = _DisTube;
// Annotate the CommonJS export names for ESM import in node:
0 && (module.exports = {
  BaseManager,
  CustomPlugin,
  DirectLinkPlugin,
  DisTube,
  DisTubeBase,
  DisTubeError,
  DisTubeHandler,
  DisTubeStream,
  DisTubeVoice,
  DisTubeVoiceManager,
  Events,
  ExtractorPlugin,
  FilterManager,
  GuildIdManager,
  Options,
  Playlist,
  Plugin,
  PluginType,
  Queue,
  QueueManager,
  RepeatMode,
  SearchResultPlaylist,
  SearchResultType,
  SearchResultVideo,
  Song,
  StreamType,
  TaskQueue,
  checkFFmpeg,
  checkIntents,
  checkInvalidKey,
  chooseBestVideoFormat,
  defaultFilters,
  defaultOptions,
  formatDuration,
  isClientInstance,
  isGuildInstance,
  isMemberInstance,
  isMessageInstance,
  isNsfwChannel,
  isObject,
  isRecord,
  isSnowflake,
  isSupportedVoiceChannel,
  isTextChannelInstance,
  isTruthy,
  isURL,
  isVoiceChannelEmpty,
  objectKeys,
  parseNumber,
  resolveGuildId,
  toSecond,
  version
});
//# sourceMappingURL=index.js.map